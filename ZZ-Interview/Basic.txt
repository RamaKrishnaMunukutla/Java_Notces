

      ......ArrayLogicalPrograms......StringLogicalPrograms.....CollectionsLogicalPrograms
	  
	  ......Alogorithms880............SortingTechniques.........
  
  
                Programs-(YOUTUBE) ---->  Learn with KrishnaSundeep

============================================================================================================

  // welcome to java  // 'A' to 'Z' ---> 65 TO 90 // 'a' to 'z' ---> 97 to 122
  
  
  Panagram(Must have 26 Characters) :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 --- The quick brown fox jumps over the lazy dog 


=============================================================================================================
   
 Program :=  
~~~~~~~~~

		Scanner sc = new Scanner(System.in);
		System.out.println("Enter a Number:: ");
		int num = sc.nextInt();
		
        //   for(int i=0;i<arr.length;i++){  

		int[] arr = { 1, 2, 5, 7, 9 };

		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length; j++) {

			}

--------------------------------------------------		

       for (int i = 0; i < n; i++) { 
            if (str.charAt(i) >= '0'  (************)
                && str.charAt(i) <= '9') { 
                return true; 
			}
		 }
		 
-------------------------------------------------------
  	
	    InputStreamReader r=new InputStreamReader(System.in);    
	    BufferedReader br=new BufferedReader(r);
		System.out.println("Enter String:: ");
		String str = br.readLine();
		
--------------------------------------------------		
		
          // Shift element of array by one
				arr[j] = arr[j - 1];   //-----------> arr[4th]= arr[3rd] Moving elements '1' index-Forword.
		
		int rand = new Random().nextInt(1000);
		
--------------------------------------------------		
	
	 char ch;
       for(ch = 'A'; ch <= 'Z'; ch++){
	   
	   }
--------------------------------------------------	

		int intArray[] = new int[256]; 	  
	        int len = str.length(); 
	        for (int i = 0; i < len; i++) 
	        	intArray[str.charAt(i)]++;  

----------------------------------------------	 
	   
		for (int i = 0; i < intArray.length; i++) {

			for (int j = 0; j < intArray.length; j++) {

			}

		}
		
		
     for(i=1;i<=lines;i++){// this loop is used to print No.Of.lines  
        for(j=1;j<=i;j++){// this loop is used to print Content-Of-Line   ( j<=i Iterates && Prints Upto 'i' )  /// (char)(65 + i)
            printf("%d ",i*j);  
        }  
        printf("\n"); 

--------------------------------------------------		
		
		 str1 = str1.replaceAll("\\s+", "");  
		
		  //Sort the array in ascending order  
	        for (int i = 0; i < arr.length; i++) {   
	            for (int j = i+1; j < arr.length; j++) {   
	               if(arr[i] > arr[j]) {  
	                   temp = arr[i];  
	                   arr[i] = arr[j];  
	                   arr[j] = temp;  
	               }   
	            }   
	        } 		
		
----------------------------------
		
  //Total possible subsets for string of size n is n*(n+1)/2  
        String arr[] = new String[len*(len+1)/2];  
		
----------------------------------

   n=6/10 [0] && n=6%10 [6]      


============================================================================================================

 Synchronized-List :=
~~~~~~~~~~~~~~~~~~~

		List<String> namesList = Collections.synchronizedList(new ArrayList<String>());

		// List methods are synchronized

		namesList.add("Alex");
		namesList.add("Brian");

		Iterator<String> iterator2 = namesList.iterator();
		while (iterator2.hasNext()) {

			System.out.println(iterator2.next());
		}

		namesList.add("rama");
		// Use explicit synchronization while iterating

		synchronized (namesList) {
			Iterator<String> iterator = namesList.iterator();
			while (iterator.hasNext()) {

				System.out.println(iterator.next());
			}
		}

====================================================================================

 Synchronized-Map :=
 ~~~~~~~~~~~~~~~~
 
 ConcurrentHashMap<Integer, String> concurrHashMap = new ConcurrentHashMap<>();
       //Put require no synchronization
        concurrHashMap.put(1, "A");
        concurrHashMap.put(2, "B");
         
        //Get require no synchronization
        concurrHashMap.get(1);
         
        Iterator<Integer> itr = concurrHashMap.keySet().iterator();
         
        //Using synchronized block is advisable
        synchronized (concurrHashMap) 
        {
            while(itr.hasNext()) {
                System.out.println(concurrHashMap.get(itr.next()));........//prints values
            }
        }

--------------------------------------------------------
 Map<Integer, String> syncHashMap = Collections.synchronizedMap(new HashMap<>());
          //Put require no synchronization
	        syncHashMap.put(1, "A");
	        syncHashMap.put(2, "B");
	         
	        //Get require no synchronization
	        syncHashMap.get(1);
	         
	        Iterator<Integer> itr = syncHashMap.keySet().iterator();
	         
	        //Using synchronized block is advisable
	        synchronized (syncHashMap) 
	        {
	            while(itr.hasNext()) {
	                System.out.println(syncHashMap.get(itr.next()));
	            }
	        }
			
===========================================NumberLogicalPrograms================================================
		
 Missing Number in Array :=
~~~~~~~~~~~~~~~~~~~~~~~~~~
 Sum of elements Upto 'n' elemets in array
 
  n(n+1) / 2  [Minus] (Sum of elements in array)
  
==========================================================================

 Move all Zeros to end-Array :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		int[] arr = { 1, 0, 3, 44, 0, 0, 66 };
		int count = 0;
		int len = arr.length;

		for (int i = 0; i < arr.length; i++) {

			if (arr[i] != 0) {
				arr[count++] = arr[i];
			}

		}

		while (count < len) {
			arr[count++] = 0;

		}

		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}

=======================================================================		
		
 Move all Zeros to Start-Array :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		                          // Storing in this Direction <------
		int[] array = { 1, 2, 0, 4, 6, 0, 9, 0, 4, 0, 3, 0, 9, 0, 1, 0, 3, 0 };

		// 2
		int current = array.length - 1;

		// 3
		for (int i = current; i >= 0; i--) {
			if (array[i] != 0) {
				array[current] = array[i];  // Non-Zero elements are stored as per Array Insertion-Order, Sort later (*****)
				current--;
			}
		}

		// 4
		while (current >= 0) {
			array[current] = 0;
			current--;
		}

		// 5
		for (int i = 0; i < array.length; i++) {
			System.out.print(array[i] + " ");
		}	
		
=======================================================================		
		
		
		
=============================================(ArrayLogicalPrograms)========================================

 Upto 3rd-Largest && 2nd Smallest :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
		int[] arr1 = {1,2,5,8,7,19,15,10};
		int max = 0, min = 0, secondMin = 0, SecondMax = 0,thirdMax=0;
		min = secondMin = Integer.MAX_VALUE;
		for (int i = 0; i < arr1.length; i++) {

			if (arr1[i] < min) {
				 min = arr1[i];
				secondMin = min;
			} else if (arr1[i] < secondMin) {
				secondMin = arr1[i];
			}
			
			if (arr1[i] > max) {
                max = arr1[i];
                SecondMax = max;
			} else if (arr1[i]> SecondMax) {
				SecondMax = arr1[i];
			} else if (arr1[i]> thirdMax) {
				thirdMax = arr1[i];
			}
			
		}

		System.out.println("Min && secondMin elements are :: " + min + " ," + secondMin);
		System.out.println("Min && secondMin elements are :: " + max + " ," + SecondMax+" "+thirdMax);

===================================================

 Reverse and Store in Another array :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		int[] arr = { 11, 112, 33, 44 };
		int[] arr2 = new int[arr.length];

		for (int i = arr.length - 1, j = 0; i >= 0; i--, j++) {
			// for (int i = arr.length-1; i >= 0; i--) {

			arr2[j] = arr[i];

		}

		for (int i = 0; i < arr2.length; i++) {
			System.out.print(arr2[i] + " ");
		}

===========================================================

 Delete Duplicates from Array :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        int[]  arr = {10, 22, 10, 20, 11, 22};
		
		int len = arr.length;
		for (int i = 0; i <len; i++) {
			for (int j = i + 1; j < len; j++) {

				if (arr[i] == arr[j]) {
				 
					arr[j] = arr[len - 1];

					len--;

					j--;
				}
			}
		}

		int[] array1 = Arrays.copyOf(arr, len);
		System.out.println("Duplicates elements are");
		for (int i = 0; i < array1.length; i++) {

			System.out.print(array1[i] + " ");
		}

	}
	
===============================================(StringLogicalPrograms)=================================================

 Print Duplicate Characters from Strings :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		
		String str = "Rama";
		int count = 0;
		char string[] = str.toCharArray();

		System.out.println("Duplicate characters in a given string: ");
		for (int i = 0; i < string.length; i++) {
			count = 1;
			for (int j = i + 1; j < string.length; j++) {
				if (string[i] == string[j] && string[i] != ' ') {
					count++;
					//string[j] = '0';
				}
			}
			if (count > 1 && string[i] != '0')
				System.out.print(string[i]+" ");
		}
		
===========================================================

 Remove Duplicate Characters from Strings :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		String string = "aabbccdefatafaz";
		char[] chars = string.toCharArray();
		Set<Character> charSet = new LinkedHashSet<Character>();
		for (char c : chars) {
			charSet.add(c);
		}

		StringBuilder sb = new StringBuilder();
		for (Character character : charSet) {
			sb.append(character);
		}
		System.out.println(sb.toString());
		
===========================================================

 Print Repeated Character form String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		str = "ramakri";
		i = str.length();
		for (c = 'A'; c <= 'z'; c++) {
			k = 0;
			for (j = 0; j < i; j++) {
				ch = str.charAt(j);
				if (ch == c) {
					k++;
				}
			}
			if (k > 0) {
				System.out.println("The character " + c + " has occurred for " + k + " times");
			}
		}
		
===========================================================

 All SubString in given String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		String str = "abcd";

		for (int i = 0; i < str.length(); i++) {
			for (int j = i + 1; j < str.length(); j++) {

				System.out.println(str.substring(i, j));
			} 
		
==========================================================  

 First Non Repeated Character form String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		String str = "aabbcd";

		for (int i = 0; i < str.length(); i++) {
			boolean unique = true;
			for (int j = 0; j < str.length(); j++) {
				if (i != j && str.charAt(i) == str.charAt(j)) {
					unique = false;
					break;
				}
			}
			if (unique) {
				System.out.println("First Repeated Character is " + str.charAt(i));
				break;
			}
		}
		
=====================================================================


		
		
		
		
=======================================(CollectionsLogicalPrograms)===================================================

 Sort elements in Map by using Values :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		List<Map.Entry<String, Integer>> list = new LinkedList<Map.Entry<String, Integer>>(hm.entrySet());
		// Sort the list
		Collections.sort(list, new Comparator<Map.Entry<String, Integer>>() {
			public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
				return (o1.getValue()).compareTo(o2.getValue());
			}
		});

		// put data from sorted list to hashmap
		HashMap<String, Integer> temp = new LinkedHashMap<String, Integer>();
		for (Map.Entry<String, Integer> aa : list) {
			temp.put(aa.getKey(), aa.getValue());
		}

       /// Printing Map 
		for (Map.Entry<String, Integer> en : temp.entrySet()) {
			System.out.println("Key = " + en.getKey() + ", Value = " + en.getValue());
		}

======================================================================================================================
 
 DeadLock in Java :=
~~~~~~~~~~~~~~~~~~~~

    String str1 = "Java";
    String str2 = "UNIX";
     
    Thread trd1 = new Thread("My Thread 1"){
        public void run(){
            while(true){
                synchronized(str1){
                    synchronized(str2){
                        System.out.println(str1 + str2);
                    }
                }
            }
        }
    };
     
    Thread trd2 = new Thread("My Thread 2"){
        public void run(){
            while(true){
                synchronized(str2){
                    synchronized(str1){
                        System.out.println(str2 + str1);
                    }
                }
            }
        }
    };
     
    public static void main(String a[]){
        MyDeadlock mdl = new MyDeadlock();
        mdl.trd1.start();
        mdl.trd2.start();
    }
}		
=======================================================================================================================

 Alogorithms880 :=
~~~~~~~~~~~~~~~~~
 --- Defined as FINITE sequence of Steps to solve a PROBLEM . 
 --- Used at designing level.
 --- Written by designer(Architect) having Domain-Knowledge.
 --- Algorithms are Analyzed for better Outcome. 


 Programs :=
~~~~~~~~~~~
 --- Used at Implementing Design,
 --- Written by Programmers
 --- Programs are need to Tested.
 
 

 "C:\Program Files\MongoDB\Server\4.4\bin\mongo.exe"


================================================================================================================
 
 SortingTechniques :=  YOUTUBE ::  JOE JAMES 
~~~~~~~~~~~~~~~~~~~~~ 

 (1) Bubble Sort  :=  O(n2)
~~~~~~~~~~~~~~~~~~
 --- Sorts elements either in ASC/DESC by comparing ADJACENT elements.
 --- If 'n' elements are present , then we need (n-1) PASSES to Sort. 
		 
 
  Logic ::
  ------
            int n = arr.length;   int temp = 0;  
     		for(int i=0; i < n; i++){  
                 for(int j=1; j < (n-i); j++){  
                          if(arr[j-1] > arr[j]){  
                                 //swap elements  
                                 temp = arr[j-1];  
                                 arr[j-1] = arr[j];  
                                 arr[j] = temp;  
				         }
			         }
		        } 
				
				
				O(log n)  >   O(n)  > O(n2)
	
========================	
	
 (2) Selection  Order :=
~~~~~~~~~~~~~~~~~~~~~~~
 --- It is Slow 		
	

 (1) Insertion Order :=
~~~~~~~~~~~~~~~~~~~~~~~
 ---




 (1) Insertion Order :=
~~~~~~~~~~~~~~~~~~~~~~~
 ---



	
===========================================================================================================		
		
 Fabinnaci Seies :=  // Storing  SUM && PREVIOUS values 
~~~~~~~~~~~~~~~~~~
		int num = 5;
		     //    <------
		int n1 = 0, n2 = 1, sum = 0;
		for (int i = 0; i < num; i++) {

			System.out.print(n1 + " ");
			sum = n1 + n2;
			n1 = n2;
			n2 = sum;
		}

===============================================		
		
		
		
		
		
		
		
		

