

  Alogorithms880......SortingTechniques.........

===============================================================================================
   
 Program :=  // welcome to java  // 'A' to 'Z' ---> 65 TO 90 // 'a' to 'z' ---> 97 to 122
~~~~~~~~~

		Scanner sc = new Scanner(System.in);
		System.out.println("Enter a Number:: ");
		int num = sc.nextInt();

--------------------------------------------------		
  	
	    InputStreamReader r=new InputStreamReader(System.in);    
	    BufferedReader br=new BufferedReader(r);
		System.out.println("Enter String:: ");
		String str = br.readLine();
		
--------------------------------------------------		
		
          // Shift element of array by one
				arr[j] = arr[j - 1];   //-----------> arr[4th]= arr[3rd] Moving elements '1' index-Forword.
		
		int rand = new Random().nextInt(1000);
		
--------------------------------------------------		
	
	 char ch;
       for(ch = 'A'; ch <= 'Z'; ch++){
	   
	   }
--------------------------------------------------	

		int intArray[] = new int[256]; 	  
	        int len = str.length(); 
	        for (int i = 0; i < len; i++) 
	        	intArray[str.charAt(i)]++;  

----------------------------------------------	 
	   
		for (int i = 0; i < intArray.length; i++) {

			for (int j = 0; j < intArray.length; j++) {

			}

		}
		
		
     for(i=1;i<=lines;i++){// this loop is used to print No.Of.lines  
        for(j=1;j<=i;j++){// this loop is used to print Content-Of-Line   ( j<=i Iterates && Prints Upto 'i' )  /// (char)(65 + i)
            printf("%d ",i*j);  
        }  
        printf("\n"); 

--------------------------------------------------		
		
		 str1 = str1.replaceAll("\\s+", "");  
		
		  //Sort the array in ascending order  
	        for (int i = 0; i < arr.length; i++) {   
	            for (int j = i+1; j < arr.length; j++) {   
	               if(arr[i] > arr[j]) {  
	                   temp = arr[i];  
	                   arr[i] = arr[j];  
	                   arr[j] = temp;  
	               }   
	            }   
	        } 		
		
----------------------------------
		
  //Total possible subsets for string of size n is n*(n+1)/2  
        String arr[] = new String[len*(len+1)/2];  
		
----------------------------------

   n=6/10 [0] && n=6%10 [6]      


============================================================================================================

 Synchronized-List :=
~~~~~~~~~~~~~~~~~~~

		List<String> namesList = Collections.synchronizedList(new ArrayList<String>());

		// List methods are synchronized

		namesList.add("Alex");
		namesList.add("Brian");

		Iterator<String> iterator2 = namesList.iterator();
		while (iterator2.hasNext()) {

			System.out.println(iterator2.next());
		}

		namesList.add("rama");
		// Use explicit synchronization while iterating

		synchronized (namesList) {
			Iterator<String> iterator = namesList.iterator();
			while (iterator.hasNext()) {

				System.out.println(iterator.next());
			}
		}

====================================================================================

 Synchronized-Map :=
 ~~~~~~~~~~~~~~~~
 
 ConcurrentHashMap<Integer, String> concurrHashMap = new ConcurrentHashMap<>();
       //Put require no synchronization
        concurrHashMap.put(1, "A");
        concurrHashMap.put(2, "B");
         
        //Get require no synchronization
        concurrHashMap.get(1);
         
        Iterator<Integer> itr = concurrHashMap.keySet().iterator();
         
        //Using synchronized block is advisable
        synchronized (concurrHashMap) 
        {
            while(itr.hasNext()) {
                System.out.println(concurrHashMap.get(itr.next()));........//prints values
            }
        }

--------------------------------------------------------
 Map<Integer, String> syncHashMap = Collections.synchronizedMap(new HashMap<>());
          //Put require no synchronization
	        syncHashMap.put(1, "A");
	        syncHashMap.put(2, "B");
	         
	        //Get require no synchronization
	        syncHashMap.get(1);
	         
	        Iterator<Integer> itr = syncHashMap.keySet().iterator();
	         
	        //Using synchronized block is advisable
	        synchronized (syncHashMap) 
	        {
	            while(itr.hasNext()) {
	                System.out.println(syncHashMap.get(itr.next()));
	            }
	        }
		
============================================================================================

 Upto 3rd-Largest && 2nd Smallest :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
		int[] arr1 = {1,2,5,8,7,19,15,10};
		int max = 0, min = 0, secondMin = 0, SecondMax = 0,thirdMax=0;
		min = secondMin = Integer.MAX_VALUE;
		for (int i = 0; i < arr1.length; i++) {

			if (arr1[i] < min) {
				 min = arr1[i];
				secondMin = min;
			} else if (arr1[i] < secondMin) {
				secondMin = arr1[i];
			}
			
			if (arr1[i] > max) {
                max = arr1[i];
                SecondMax = max;
			} else if (arr1[i]> SecondMax) {
				SecondMax = arr1[i];
			} else if (arr1[i]> thirdMax) {
				thirdMax = arr1[i];
			}
			
		}

		System.out.println("Min && secondMin elements are :: " + min + " ," + secondMin);
		System.out.println("Min && secondMin elements are :: " + max + " ," + SecondMax+" "+thirdMax);

============================================================================================

 Delete Duplicates from Array :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        int[]  arr = {10, 22, 10, 20, 11, 22};
		
		int len = arr.length;
		for (int i = 0; i <len; i++) {
			for (int j = i + 1; j < len; j++) {

				if (arr[i] == arr[j]) {
				 
					arr[j] = arr[len - 1];

					len--;

					j--;
				}
			}
		}

		int[] array1 = Arrays.copyOf(arr, len);
		System.out.println("Duplicates elements are");
		for (int i = 0; i < array1.length; i++) {

			System.out.print(array1[i] + " ");
		}

	}
	
======================================================================================

 Run-rate :=
~~~~~~~~~~
		if (runs < 100) {
			float runRate = runs / Overs;
			return runs + " runs in " + Overs + " Overs @ " + runRate + " runs per over";

		} else {
			int n1, n2 = 0;
			n1 = (int) Overs;
			n2 = (int) Math.round((Overs % 1) * 100);
			float n3 = (float) n2 / 100;
			float f1 = n1 * 6;
			float f2 = n3 * 10;
			float total = f1 + f2;
			int balls = (int) total;
			
==================================================================================

//		Scanner sc= new Scanner(System.in);
//		System.out.println("Enter total number");
//		int n=sc.nextInt();
//		int[] arr= new int[n];
//		System.out.println("Enter elements now:: ");
//		for(int i=0;i<n;i++) {
//			arr[i]=sc.nextInt();
//		}
//		System.out.println("Enter element you want to remove:: ");
//		int remove= sc.nextInt();
//		
//		for(int i=remove;i<arr.length-1;i++) {
//			
//			arr[i]=arr[i+1];
//			  
//			
//		}
//		
//		
//		for(int i=0;i<arr.length;i++) {
//		System.out.println(arr[i]);
//		}
		
===========================================================================================================

 Alogorithms880 :=
~~~~~~~~~~~~~~~~~
 --- Defined as FINITE sequence of Steps to solve a PROBLEM . 
 --- Used at designing level.
 --- Written by designer(Architect) having Domain-Knowledge.
 --- Algorithms are Analyzed for better Outcome. 


 Programs :=
~~~~~~~~~~~
 --- Used at Implementing Design,
 --- Written by Programmers
 --- Programs are need to Tested.
 
 

 "C:\Program Files\MongoDB\Server\4.4\bin\mongo.exe"


================================================================================================================
 
 SortingTechniques :=  YOUTUBE ::  JOE JAMES 
~~~~~~~~~~~~~~~~~~~~~ 

 (1) Bubble Sort  :=  O(n2)
~~~~~~~~~~~~~~~~~~
 --- Sorts elements either in ASC/DESC by comparing ADJACENT elements.
 --- If 'n' elements are present , then we need (n-1) PASSES to Sort. 
		 
 
  Logic ::
  ------
            int n = arr.length;   int temp = 0;  
     		for(int i=0; i < n; i++){  
                 for(int j=1; j < (n-i); j++){  
                          if(arr[j-1] > arr[j]){  
                                 //swap elements  
                                 temp = arr[j-1];  
                                 arr[j-1] = arr[j];  
                                 arr[j] = temp;  
				         }
			         }
		        } 
				
				
				O(log n)  >   O(n)  > O(n2)
	
========================	
	
 (2) Selection  Order :=
~~~~~~~~~~~~~~~~~~~~~~~
 --- It is Slow 		
	

 (1) Insertion Order :=
~~~~~~~~~~~~~~~~~~~~~~~
 ---




 (1) Insertion Order :=
~~~~~~~~~~~~~~~~~~~~~~~
 ---



	
===========================================================================================================		
		
 Fabinnaci Seies :=  // Storing  SUM && PREVIOUS values 
~~~~~~~~~~~~~~~~~~
		int num = 5;
		     //    <------
		int n1 = 0, n2 = 1, sum = 0;
		for (int i = 0; i < num; i++) {

			System.out.print(n1 + " ");
			sum = n1 + n2;
			n1 = n2;
			n2 = sum;
		}

===============================================		
		
		
		
		
		
		
		
		

