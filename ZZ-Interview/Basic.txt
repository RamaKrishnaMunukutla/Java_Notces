

      ......Patterns900.........NumberLogicalPrograms.......
	  
	  ArrayLogicalPrograms......StringLogicalPrograms.....CollectionsLogicalPrograms
	  
	  ...FileHandling880.........Alogorithms880...........SortingTechniques.........DataStructures.....
	  
	  ...SingletonDemoEg.........SearchAlgorithm660
  
  
                Programs-(YOUTUBE) ---->  Learn with KrishnaSundeep
				
				https://codeforwin.org/2016/06/number-pattern-programs-in-c.html
				https://codeforwin.org/2018/04/file-handling-programming-exercises-and-solutions-in-c.html
				https://codeforwin.org/2016/03/functions-programming-exercises-and-solutions-in-c.html
				
				https://github.com/kdn251/interviews
				https://github.com/kdn251/interview-practice
				
				https://www.youtube.com/c/ProgrammingTutorials1M/playlists
				
				[ https://javaconceptoftheday.com/big-o-notations-tutorials/ ]
				[ https://www.javatpoint.com/java-programs ]
				[ https://www.mysqltutorial.org/tryit/query/mysql-group_concat/#9 ]
				
				
		Programming Tutorials ----> https://www.youtube.com/channel/UCuix1GOcmoqqWcHh1W1dWAg/playlists
		    TECH DOSE  -----------> https://www.youtube.com/channel/UCnxhETjJtTPs37hOZ7vQ88g/playlists
				
				
				  Searching && Sorting ----> KK-Java /// Saradhi (*********)
				  
				
 >> java programs github
 
 >> java 8 real time examples
 
 >> sql queries practice
 
============================================================================================================

  // welcome to java  // 'A' to 'Z' ---> 65 TO 90 // 'a' to 'z' ---> 97 to 122
  
  
        https://javahungry.blogspot.com/2017/09/25-different-number-pattern-programs-in-java.html
		
		  i ---> Same Numbers /// j ---> Different Numbers
		  
		  
		             str[j] = str[j + 1]; ----> Array Size Decreasing 
					 
					 str[j] = str[j - 1]; ----> Array Size Increasing  
		
		
 Best , Average,Worst Cases :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
* Best Case       :  O(n)
* Average Case    :  O(n^2)
* Worst Case      :  O(n^2)
* Worst Case      :  O(1)


 Best , Average,Worst Cases :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*  Best Case     :    O(n log n) , or O(n)  
* Average Case   :    O(n log n)

=================================================  
  
  Panagram(Must have 26 Characters) :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 --- The quick brown fox jumps over the lazy dog 


=============================================================================================================
   
 Program :=  
~~~~~~~~~

		Scanner sc = new Scanner(System.in);
		System.out.println("Enter a Number:: ");
		int num = sc.nextInt();
		
        //   for(int i=0;i<arr.length;i++){  

		int[] arr = { 1, 2, 5, 7, 9 };

		for (int i = 0; i < arr.length; i++) {
			for (int j = 0; j < arr.length; j++) {

			}


	    InputStreamReader r=new InputStreamReader(System.in);    
	    BufferedReader br=new BufferedReader(r);
		System.out.println("Enter String:: ");
		String str = br.readLine();
		
		
--------------------------------------------------		

       for (int i = 0; i < n; i++) { 
            if (str.charAt(i) >= '0')  (************)
                && str.charAt(i) <= '9') { 
                return true; 
			}
		 }
		 
-------------------------------------------------------
  	
          // Shift element of array by one
				arr[j] = arr[j - 1];   //-----------> arr[4th]= arr[3rd] Moving elements '1' index-Forword.
		
		int rand = new Random().nextInt(1000);
		
--------------------------------------------------		
		
		int intArray[] = new int[256]; 	  
	        int len = str.length(); 
	        for (int i = 0; i < len; i++) 
	        	intArray[str.charAt(i)]++;
		
--------------------------------------------------		
	
	 char ch;
       for(ch = 'A'; ch <= 'Z'; ch++){
	   
	   }
--------------------------------------------------	

  

----------------------------------------------	 
	   
		for (int i = 0; i < intArray.length; i++) {

			for (int j = 0; j < intArray.length; j++) {

			}

		}

--------------------------------------------------		
		
		 str1 = str1.replaceAll("\\s+", "");  
		
		  //Sort the array in ascending order  
	        for (int i = 0; i < arr.length; i++) {   
	            for (int j = i+1; j < arr.length; j++) {   
	               if(arr[i] > arr[j]) {  
	                   temp = arr[i];  
	                   arr[i] = arr[j];  
	                   arr[j] = temp;  
	               }   
	            }   
	        } 		
		
----------------------------------
		
  //Total possible subsets for string of size n is n*(n+1)/2  
        String arr[] = new String[len*(len+1)/2];  
		
----------------------------------

   n=6/10 [0] && n=6%10 [6]    

-------------------------------------------------

 Reverse int[] :=
~~~~~~~~~~~~~~~~~
   
   j = i - 1;     
	i = 0;         
	scanner.close();
	while(i<j)
	{
  	   temp = number[i];
	   number[i] = number[j];
	   number[j] = temp;
	   i++;
	   j--;
	}
	
============================================================================================================

 Small to Big Characters :=
~~~~~~~~~~~~~~~~~~~~~~~~~~
		for (i = 0; i < s.length(); i++) {
			int ch = s.charAt(i);
			if (ch > 64 && ch < 91) {
				ch = ch + 32;
				System.out.print((char) ch);
			} else if (ch > 96 && ch < 123) {
				ch = ch - 32;
				System.out.print((char) ch);
			}
			if (ch == 32)
				System.out.print(" ");
		}

		
==============================================================================================================

 Synchronized-List :=
~~~~~~~~~~~~~~~~~~~

		List<String> namesList = Collections.synchronizedList(new ArrayList<String>());

		// List methods are synchronized

		namesList.add("Alex");
		namesList.add("Brian");

		Iterator<String> iterator2 = namesList.iterator();
		while (iterator2.hasNext()) {

			System.out.println(iterator2.next());
		}

		namesList.add("rama");
		// Use explicit synchronization while iterating

		synchronized (namesList) {
			Iterator<String> iterator = namesList.iterator();
			while (iterator.hasNext()) {

				System.out.println(iterator.next());
			}
		}

====================================================================================

 Synchronized-Map :=
 ~~~~~~~~~~~~~~~~
 
 ConcurrentHashMap<Integer, String> concurrHashMap = new ConcurrentHashMap<>();
       //Put require no synchronization
        concurrHashMap.put(1, "A");
        concurrHashMap.put(2, "B");
         
        //Get require no synchronization
        concurrHashMap.get(1);
         
        Iterator<Integer> itr = concurrHashMap.keySet().iterator();
         
        //Using synchronized block is advisable
        synchronized (concurrHashMap) 
        {
            while(itr.hasNext()) {
                System.out.println(concurrHashMap.get(itr.next()));........//prints values
            }
        }

--------------------------------------------------------
 Map<Integer, String> syncHashMap = Collections.synchronizedMap(new HashMap<>());
          //Put require no synchronization
	        syncHashMap.put(1, "A");
	        syncHashMap.put(2, "B");
	         
	        //Get require no synchronization
	        syncHashMap.get(1);
	         
	        Iterator<Integer> itr = syncHashMap.keySet().iterator();
	         
	        //Using synchronized block is advisable
	        synchronized (syncHashMap) 
	        {
	            while(itr.hasNext()) {
	                System.out.println(syncHashMap.get(itr.next()));
	            }
	        }
			
==================================================================================================================

  Patterns900 :=   Num---i---1  ///  (N-i +1)  (Num-i-1)  (i * 2 - 1) /// I --- SAME /// J -- CHANGES
~~~~~~~~~~~~~~~~~~

                          1st For Loop ---> No fo Lines (Or) 1st  Line 

                             Ulta '7' ----> (Rev-For-Loop) // for (int i = rows; i >= 1; i--)  ////  
							                                 for (int j = 1; j <= i; j++)
                         
						  Normal Slant ---->  '<i'	(98765... / 12345...)

                   
                         3rd For Loop -----> either 'num' / 'rowCount' 				   
	
  
                         j <= i*2 ----> Doubles Spaces 			 
				 
	                    for (int i = rows-1; i >= 1; i--)  ----> Reverse 'L' Print 
  
  
=================================================

	for (int i = noOfRows; i > 0; i--) {

			for (int j = noOfRows; j > 0; j--) {
				System.out.println();
			}

			 System.out.println();
		}
		
==================================================
  
  for(int j = i-1; j >= 1; j--)   /// Other Pattern with less than Number in Reverse 
   {
      System.out.print(j+" ");
   }
   
			
   for(int j = i; j <= num ; j++)  /// Other Pattern with 
      { 
         System.out.print(j); 
      } 
	  
	  
   for (int j = 1; j <= rowCount; j++)
      {
        System.out.print("* ");
      }
	  
====================
	  
   for (int j = 1; j <= i*2; j++)  /// For Rev 'L'&& 'L' Combined Pattern 
      {
        System.out.print(" ");
      }
	  
   for (int j = rowCount-1; j >= 1; j--)  /// For Rev 'L'&& 'L' Combined Pattern  ('L'Pattern) 
      {               
         System.out.print(j+" ");            
      } 
====================
	  
   int rowCount = noOfRows; ----> /// For Rev 'L'&& 'L' Combined Pattern  ("Katti") Pattern 
   
============================================================================

===========================================[ NumberLogicalPrograms ]================================================			
			
 NumberLogicalPrograms :=
~~~~~~~~~~~~~~~~~~~~~~~

 Reverse Number :=
~~~~~~~~~~~~~~~~~~~
    while(num != 0)
        {
            rem = num%10;
            rev = rev*10 + rem;
            num = num/10;
        }


 Palindrome (22522)  :=
~~~~~~~~~~~~~~~~~~~~~
    while(num != 0)
        {
            rem = num%10;
            rev = rev*10 + rem;
            num = num/10;
        }
		
		
 ArmStrong Number (153):=  /// Sum of Cubes 
~~~~~~~~~~~~~~~~~~~~~~~~~ 
    while(nu != 0)
        {
            rem = nu%10;
            num = num + rem*rem*rem;
            nu = nu/10;
        }	
		
		
 Fibonacci Series (153):=
~~~~~~~~~~~~~~~~~~~~~~~~~ 
  
        int firstTerm = 0, int secondTerm = 1, thirdTerm = 0;
		
		while (thirdTerm < inputNumber)
        {
            thirdTerm = firstTerm + secondTerm;
             
            firstTerm = secondTerm;
             
            secondTerm = thirdTerm;
        }
		
		
		
  Sum of Digits :=
~~~~~~~~~~~~~~~~~

        while (copyOfInputNumber != 0)
        {
            //Getting last digit of the input number
 
            int lastDigit = copyOfInputNumber%10;
 
            //Adding last digit to sum
 
            sum = sum + lastDigit;
 
            //Removing last digit from the input number
 
            copyOfInputNumber = copyOfInputNumber/10;
        }
		
		
		
		
 Count Number of Digits in Number :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  while(num > 0){
  
      num = num / 10;
	  count ++ ;
  
   }


======================================================================== 

 Prime Numbers within Range :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 int i, j, end=19, isPrime, sum=0;

		    for(i=2; i<=end; i++)
		    {
		        isPrime = 1;
		        for(j=2; j<=i/2 ;j++)
		        {
		            if(i%j==0)
		            {
		                isPrime = 0;
		                break;
		            }
		        }

	
		        if(isPrime==1)
		        {
		            sum += i;
		        }
		    }
		
		    System.out.println(end+" "+sum);
  
========================================================================

  Palindrome  within Range :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 static int isPalindrome(int n) 
    { 
   
        int rev = 0; 
        for (int i = n; i > 0; i /= 10) 
            rev = rev * 10 + i % 10; 
              
        return(n == rev) ? 1 : 0; 
    } 
      
    static void countPal(int min, int max) 
    { 
        for (int i = min; i <= max; i++) 
            if (isPalindrome(i)==1) 
                System.out.print(i + " "); 
    } 
  
========================================================================
 smallest-and-biggest-possible-palindrome-word-in-a-given-string  :=~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
package com.demo;

public class Demo {

	// Function to check if a 
    // word is palindrome 
    public static boolean checkPalin(String word) 
    { 
  
        int n = word.length(); 
  
        // making the check case 
        // case insensitive 
        word = word.toLowerCase(); 
  
        // loop to check palindrome 
        for (int i = 0; i < n; i++, n--) 
        { 
            if (word.charAt(i) != word.charAt(n - 1)) 
                return false; 
        } 
  
        return true; 
    } 
  
    // Determine the smallest and biggest 
    // palindromes in a given string 
    public static void lengthPalindrome(int temp, String words[]) 
    { 
        
        int count = 0; 
        String smallest = "", longest = ""; 
        
        for (int i = 0; i < temp; i++) { 
            
            if (checkPalin(words[i])) { 
                count++; 
                
                // Initialize smallest and longest 
                // when first palindromic word 
                // is found 
                if (count == 1) 
                    smallest = longest = words[i]; 
  
                // Compare smallest and longest with each 
                // palindromic words 
                else { 
                    
                    // If length of smallest is greater 
                    // than next palindromic word then 
                    // Store that word in smallest 
                    if (smallest.length() 
                        > words[i].length()) 
                        smallest = words[i]; 
  
                    // If length of longest is less 
                    // than next palindromic word then 
                    // Store that word in longest 
                    if (longest.length() 
                        < words[i].length()) 
                        longest = words[i]; 
                } 
            } 
        } 
  
        if (count == 0) 
            
            System.out.println("No palindrome found"); 
        
        else { 
            
            System.out.println("Smallest palindrome: "
                               + smallest); 
            System.out.println("Biggest palindrome: "
                               + longest); 
        } 
    } 
  
    public static void main(String[] args) 
    { 
        
        String string = "Wow Madam is driving racecar"; 
        String word = ""; 
        
        String[] words = new String[100]; 
        int temp = 0; 
  
        // Add extra space after string 
        // to get the last word 
        string = string + " "; 
  
        for (int i = 0; i < string.length(); i++) { 
            
            // Split the string into words 
            if (string.charAt(i) != ' ') { 
                word = word + string.charAt(i); 
            } 
            
            else { 
                
                // Add word to array words 
                words[temp] = word; 
                temp++; 
                word = ""; 
            } 
        } 
        
        System.out.println("Inputted String : " + string); 
        lengthPalindrome(temp, words); 
    } 
}

==============================================================================

 Missing Number in Aray :=
~~~~~~~~~~~~~~~~~~~~~~~~~~
 Sum of elements Upto 'n' elemets in array
 
  n(n+1) / 2  [Minus] (Sum of elements in array)
  
		 int[] arr= {1,3,4};
		 
     		 int n=arr.length+1;
		        int sum=n*(n+1)/2;
		        int restSum=0;
		        for (int i = 0; i < arr.length; i++) {
		            restSum+=arr[i];
		        }
		        int missingNumber=sum-restSum;
		        System.out.println( missingNumber);
		     
     
============================================================================

 Move all Zeros to end-Array :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		int[] arr = { 1, 0, 3, 44, 0, 0, 66 };
		int count = 0;
		int len = arr.length;

		for (int i = 0; i < arr.length; i++) {

			if (arr[i] != 0) {
				arr[count++] = arr[i];
			}

		}

		while (count < len) {
			arr[count++] = 0;

		}

		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}

=======================================================================		
		
 Move all Zeros to Start-Array :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		                          // Storing in this Direction <------
		int[] array = { 1, 2, 0, 4, 6, 0, 9, 0, 4, 0, 3, 0, 9, 0, 1, 0, 3, 0 };

		// 2
		int current = array.length - 1;

		// 3
		for (int i = current; i >= 0; i--) {
			if (array[i] != 0) {
				array[current] = array[i];  // Non-Zero elements are stored as per Array Insertion-Order, Sort later (*****)
				current--;
			}
		}

		// 4
		while (current >= 0) {
			array[current] = 0;
			current--;
		}

		// 5
		for (int i = 0; i < array.length; i++) {
			System.out.print(array[i] + " ");
		}	
		
=========================================================

        int count = 0;   
     
        for (int i = 0; i < n; i++) {
            if (arr[i] == 0)
                count++;
        }
 
        for (int i = 0; i < count; i++)
            arr[i] = 0;
 
        for (int i = count; i < n; i++)
            arr[i] = 1;
    
         return arr;
     }
	 
	 
		
======================================================================================

 Reverse And Add A Number Until You Get A Palindrome :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	static int reverseNumber(int number) {
		int reverse = 0;

		int rem = 0;

		while (number != 0) {
			rem = number % 10;

			reverse = (reverse * 10) + rem;

			number = number / 10;
		}

		return reverse;
	}

	// Method To Check For Palindrome

	static boolean checkPalindrome(int number) {
		int reverse = reverseNumber(number);

		if (reverse == number) {
			return true;
		} else {
			return false;
		}
	}

	// Method To Reverse And Add Given Number Until You Get A Palindrome

	static void reverseAndAdd(int number) {
		if (checkPalindrome(number)) {
			System.out.println("Given Number is already a palindrome");
		} else {
			while (!checkPalindrome(number)) {
				int reverse = reverseNumber(number);

				int sum = number + reverse;

				System.out.println(number + " + " + reverse + " = " + sum);

				number = sum;
			}
		}
	} 
	
=============================================(ArrayLogicalPrograms)========================================

---> use Arrays.copyOf() method (or) System.arrayCopy() to start copying elements from one array to another in Java 


=============================================================================

 Upto 3rd-Largest && 2nd Smallest :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
		int[] arr1 = {1,2,5,8,7,19,15,10};
		int max = 0, min = 0, secondMin = 0, SecondMax = 0,thirdMax=0;
		min = secondMin = Integer.MAX_VALUE;
		for (int i = 0; i < arr1.length; i++) {

			if (arr1[i] < min) {
				 min = arr1[i];
				secondMin = min;
			} else if (arr1[i] < secondMin) {
				secondMin = arr1[i];
			}
			
			if (arr1[i] > max) {
                max = arr1[i];
                SecondMax = max;
			} else if (arr1[i]> SecondMax) {
				SecondMax = arr1[i];
			} else if (arr1[i]> thirdMax) {
				thirdMax = arr1[i];
			}
			
		}

		System.out.println("Min && secondMin elements are :: " + min + " ," + secondMin);
		System.out.println("Min && secondMin elements are :: " + max + " ," + SecondMax+" "+thirdMax);
		
=======================================

 public static int getThirdLargest(int[] a, int total){ 
 int temp;  
for (int i = 0; i < total; i++)   
        {  
            for (int j = i + 1; j < total; j++)   
            {  
                if (a[i] > a[j])   
                {  
                    temp = a[i];  
                    a[i] = a[j];  
                    a[j] = temp;  
                }  
            }  
        }  
       return a[total-3];
   
   
=============================================================================================================

   Sort in Ascending Order :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   for (int i = 0; i < arr.length; i++) {     
            for (int j = i+1; j < arr.length; j++) {     
               if(arr[i] > arr[j]) {    
                   temp = arr[i];    
                   arr[i] = arr[j];    
                   arr[j] = temp;    
               }     
            }     
        }
	
=============================================================================================================	
 
 Copy Elements form One Array to another :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        //Initialize array   
        int [] arr1 = new int [] {1, 2, 3, 4, 5};   
          
        //Create another array arr2 with size of arr1  
        int arr2[] = new int[arr1.length];  
          
        //Copying all elements of one array into another  
        for (int i = 0; i < arr1.length; i++) {   
            arr2[i] = arr1[i];   
        }   
		
=============================================================================================================	
 
 Print Even Index Elements in Arary  :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
	  for (int i = 0; i < arr.length; i = i+2) {  
            System.out.println(arr[i]);  
        }
		
		
=============================================================================================================

 Copy elements form One Array to Another   :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

       int [] arr1 = new int [] {1, 2, 3, 4, 5};     
         //Create another array arr2 with size of arr1    
        int arr2[] = new int[arr1.length];    
        //Copying all elements of one array into another    
        for (int i = 0; i < arr1.length; i++) {     
            arr2[i] = arr1[i];     
        }  
		
=============================================================================================================

 Frequency of Each Digit in Number  :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		int[] arr = new int[] { 1, 2, 8, 3, 2, 2, 2, 5, 1 };
		// Array fr will store frequencies of element
		int[] fr = new int[arr.length];
		int visited = -1;

		for (int i = 0; i < arr.length; i++) {
			int count = 1;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[i] == arr[j]) {
					count++;
					// To avoid counting same element again
					fr[j] = visited;
				}
			}
			if (fr[i] != visited)
				fr[i] = count;
		}

		// Displays the frequency of each element present in array
		System.out.println("---------------------");
		System.out.println(" Element | Frequency");
		System.out.println("---------------------");
		for (int i = 0; i < fr.length; i++) {
			if (fr[i] != visited)
				System.out.println("    " + arr[i] + "    |    " + fr[i]);
		}	

=============================================================================================================

  Remove Duplicate form Array :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


		int[] arrayWithDuplicates = { 4, 3, 2, 4, 9, 2 };
		int arrLength = arrayWithDuplicates.length;

		for (int i = 0; i < arrLength; i++) {
			for (int j = i + 1; j < arrLength; j++) {
				// If any two elements are found equal

				if (arrayWithDuplicates[i] == arrayWithDuplicates[j]) {
					// Replace duplicate element with last unique element

					arrayWithDuplicates[j] = arrayWithDuplicates[arrLength - 1];

					// Decrementing arrLength

					arrLength--;

					// Decrementing j

					j--;
				}

			}
		}

		int[] arrayWithoutDuplicates = Arrays.copyOf(arrayWithDuplicates, arrLength);

		for (int i = 0; i < arrayWithoutDuplicates.length; i++) {

			System.out.println(arrayWithDuplicates[i] + " ");

		}

=============================================

  for(i=0; i<size; i++)
    {
        for(j=i+1; j<size; j++)
        {
            /* If any duplicate found */
            if(arr[i] == arr[j])
            {
                /* Delete the current duplicate element */
                for(k=j; k<size; k++)
                {
                    arr[k] = arr[k + 1];
                }

                /* Decrement size after removing duplicate element */
                size--;

                /* If shifting of elements occur then don't increment j */
                j--;
            }
        }
    }
	
=============================================================================================================

 Reverse and Store in Another array :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		int[] arr = { 11, 112, 33, 44 };
		int[] arr2 = new int[arr.length];

		for (int i = arr.length - 1, j = 0; i >= 0; i--, j++) {
			// for (int i = arr.length-1; i >= 0; i--) {

			arr2[j] = arr[i];

		}

		for (int i = 0; i < arr2.length; i++) {
			System.out.print(arr2[i] + " ");
		}

===========================================================

 Delete Duplicates from Array :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        int[]  arr = {10, 22, 10, 20, 11, 22};
		
		int len = arr.length;
		for (int i = 0; i <len; i++) {
			for (int j = i + 1; j < len; j++) {

				if (arr[i] == arr[j]) {
				 
					arr[j] = arr[len - 1];

					len--;

					j--;
				}
			}
		}

		int[] array1 = Arrays.copyOf(arr, len);
		System.out.println("Duplicates elements are");
		for (int i = 0; i < array1.length; i++) {

			System.out.print(array1[i] + " ");
		}

	}

==================================================================================

 Unique triplets such that sum of all the three elements :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  for(int i = 0; i < nums.length; i++){
            for(int j = i; j < nums.length ;j++){
                for(int k = j; k<nums.length;k++){
                    if ( i != j && j != k && i != k && (nums[i] + nums[j] + nums[k] == target)){
                        List<Integer> inner_List = new ArrayList<Integer>(3);
                        inner_List.add(nums[i]);
                        inner_List.add(nums[j]);
                        inner_List.add(nums[k]);
                        my_List.add(inner_List);
                    }
                }
            }
        }
       return my_List;
	   
==================================================================================	   

 Delete an Element in Array :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   System.out.print("Enter Element to be Delete : ");
       del = scan.nextInt();
       for(i=0; i<size; i++)
       {
           if(arr[i] == del)
           {
               for(int j=i; j<(size-1); j++)
               {
                   arr[j] = arr[j+1];
               }
               count++;
               break;
           }
       }
	   
=========================================

   int removeIndex = 1;

   for(int i = removeIndex; i < my_array.length -1; i++){
        my_array[i] = my_array[i + 1];
      }

==================================================================================

 Permutation of Number :=
~~~~~~~~~~~~~~~~~~~~~~~~~~



============================================================================
	
===============================================(StringLogicalPrograms)=================================================


   for (int i = 0; i < inputString.length(); i++) 
        {
            char ch = inputString.charAt(i);
        }
		
    https://github.com/journaldev/journaldev/tree/master/CoreJavaProjects/String-Programs/src
		
====================================================================================================

 Add Numbers in String :=
~~~~~~~~~~~~~~~~~~~~~~~
 int l = stng.length();
  int sum = 0;
  String temp = "";
  for (int i = 0; i < l; i++) 
  {
    if (Character.isDigit(stng.charAt(i))) 
	{
      if (i < l-1 && Character.isDigit(stng.charAt(i+1))) 
	  {
        temp += stng.charAt(i);
      }
      else 
	  {
        temp += stng.charAt(i);
        sum += Integer.parseInt(temp);
        temp = "";
      }
    }
  }
  return sum;
}

====================================================================================================

 Swap 2 Strings  :=
~~~~~~~~~~~~~~~~~ 
         String a = "Love";  
        String b = "You";  
        System.out.println("Before swap: " + a + " " + b);  
        a = a + b;  
        b = a.substring(0, a.length() - b.length());  
        a = a.substring(b.length());  
        System.out.println("After : " + a + " " + b); 
		
============================================================================

 Replace Specific Character in String  :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       
	   String st = "helloABworldABGfG"; 
        char str[] = st.toCharArray(); 
		
        for (int i = 1; i < str.length; i++) 
        { 
            // If previous character is 'A' and 
            // current character is 'B" 
            if (str[i - 1] == 'A' && str[i] == 'B') 
            { 
                // Replace previous character with 
                // 'C' and move all subsequent 
                // characters one position back 
                str[i - 1] = 'C'; 
                int j; 
                for (j = i; j < str.length - 1; j++) 
                    str[j] = str[j + 1]; 
                str[j] = ' '; 
                  
            } 
	  }
         
=========================

        String str = "Geeks Gor Geeks"; 
  
        // Get the index 
        int index = 6; 
  
        // Get the character 
        char ch = 'F'; 
  
        // Print the original string 
        System.out.println("Original String = "
                           + str); 
  
        str = str.substring(0, index) 
              + ch 
              + str.substring(index + 1); 
  
        // Print the modified string 
        System.out.println("Modified String = "
                           + str); 
    }        
	
======================================================


  static final int NO_OF_CHARS = 256;
    static char count[] = new char[NO_OF_CHARS];
 
    /* calculate count of characters 
       in the passed string */
    static void getCharCountArray(String str)
    {
        for (int i = 0; i < str.length(); i++)
            count[str.charAt(i)]++;
    }
===========================================================================================

 Remove Specific Character form String : 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   public static void main(String args[]) {
      String str = "this is Java";
      System.out.println(removeCharAt(str, 3));
   }
   public static String removeCharAt(String s, int pos) {
      return s.substring(0, pos) + s.substring(pos + 1);
   }
		
============================================================================	
 
   Occurance of Character in String :=   (******************)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        String s = "Java is java again java again";
 
        char c = 'a';
 
        int count = s.length() - s.replace("a", "").length();
 
        System.out.println("Number of occurances of 'a' in "+s+" = "+count);

============================================================================

 Remove all white Spaces in String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
         String str = "India     Is My    Country";    
        String noSpaceStr = str.replaceAll("\\s", ""); // using built in method  
        System.out.println(noSpaceStr);  
       
	   char[] strArray = str.toCharArray();  
        StringBuffer stringBuffer = new StringBuffer();  
        
		for (int i = 0; i < strArray.length; i++) {  
            if ((strArray[i] != ' ') && (strArray[i] != '\t')) {  
                stringBuffer.append(strArray[i]);  
            }  
        }  
        String noSpaceStr2 = stringBuffer.toString();  
        System.out.println(noSpaceStr2);  

============================================================================

 Remove Duplicates from String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        Map<Character, Integer> baseMap = new HashMap<Character, Integer>();  
        char[] charArray = str.toCharArray();  
        for (Character ch : charArray) {  
            if (baseMap.containsKey(ch)) {  
                baseMap.put(ch, baseMap.get(ch) + 1);  
            } else {  
                baseMap.put(ch, 1);  
            }  
        }  
        Set<Character> keys = baseMap.keySet();  
        for (Character ch : keys) {  
            if (baseMap.get(ch) > 1) {  
                System.out.println(ch + "  is " + baseMap.get(ch) + " times");  
            }  
        } 
		
============================================================================		

 Last Occurance of Character in String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      String strOrig = "Hello world ,Hello Reader";
      int lastIndex = strOrig.lastIndexOf("Hello");
      
      if(lastIndex == - 1){
         System.out.println("Hello not found");
      } else {
         System.out.println("Last occurrence of Hello is at index "+ lastIndex);
      }	
	  
============================================================================

 Reverse The String With Preserving The Position Of Spaces :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      char[] inputStringArray = inputString.toCharArray();
         
        //Defining a new char array 'resultArray' with same size as inputStringArray
         
        char[] resultArray = new char[inputStringArray.length];
         
        //First for loop : 
        //For every space in the 'inputStringArray', 
        //we insert spaces in the 'resultArray' at the corresponding positions 
         
        for (int i = 0; i < inputStringArray.length; i++) 
        {
            if (inputStringArray[i] == ' ') 
            {
                resultArray[i] = ' ';
            }
        }
         
        //Initializing 'j' with length of resultArray
         
        int j = resultArray.length-1;
                 
        //Second for loop :
        //we copy every non-space character of inputStringArray 
        //from first to last at 'j' position of resultArray
         
        for (int i = 0; i < inputStringArray.length; i++)
        {
            if (inputStringArray[i] != ' ') 
            {
                //If resultArray already has space at index j then decrementing 'j'
                 
                if(resultArray[j] == ' ')
                {
                    j--;
                }
                 
                resultArray[j] = inputStringArray[i];
                 
                j--;
            }
        
		
=====================================================================================================

  Swaping First and Last Characters in String  :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
        char[] ch = str.toCharArray(); 
  
        // Swapping first and the last 
        // character of a string 
        char temp = ch[0]; 
        ch[0] = ch[ch.length - 1]; 
        ch[ch.length - 1] = temp; 
  
        // Converting character to 
        // string and return 
        return String.valueOf(ch);
 
 Permutation of String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	private static void permutation(String empty, String word) {
		 
		method++;
		if (word.isEmpty()) {
			System.err.println(empty + word);
			

		} else {
			for (int i = 0; i < word.length(); i++) {
				forloop++;
				String s1 = empty + word.charAt(i);
				String s2 = word.substring(0, i) + word.substring(i + 1, word.length());
				System.out.println(s1 + "  " + s2);
				permutation(empty + word.charAt(i), word.substring(0, i) + word.substring(i + 1, word.length()));
			}
		}

	}
	
========================================================================================================

 create a new string taking specified number of characters from first and last position of a given string. := (*********)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
             return str.substring(0,n) + str.substring(str.length()- n, str.length());

=============================

 Others :=
~~~~~~~~~~
(str.substring(0,2).equals(str.substring(len-2, len)))
      return str.substring(2,len);
      else return str;
	  
========================================================================================================

if the first or last characters are same return the string without those characters otherwise return the string := (*****)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if (stng.length() == 0)
    return stng;
  if (stng.length() == 1)
  {
    if (stng.charAt(0) == 't')
      return "";
    else
      return stng;
  }
  if (stng.charAt(0) == 't')
    stng = stng.substring(1,stng.length());
  if (stng.charAt(stng.length()-1) == 't')
    stng = stng.substring(0,stng.length()-1);
  return stng;
  
  
=============================================================================================================

  Remove a specified character and its immediate left and right characters.:=   (****************)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   for (int i = 0; i < len; i++) 
  {
    if (i == 0 && stng.charAt(i) != '#')
      resultString += stng.charAt(i);
    if (i > 0 && stng.charAt(i) != '#' && stng.charAt(i-1) != '#')
      resultString += stng.charAt(i);
    if (i > 0 && stng.charAt(i) == '#' && stng.charAt(i-1) != '#')
      resultString = resultString.substring(0,resultString.length()-1);
  }
  return resultString;

=============================================================================================================

 create a new string repeating every character twice of a given string.:= (**********)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 for (int i = 0; i < l; i++) 
  {
    newstring += stng.substring(i,i+1) + stng.substring(i, i+1);
  }
  return newstring;
  
================================================================================================================

 Each character of two string will come Adjacently := (**********)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  int len1 = stng1.length();
  int len2 = stng2.length();
  int max_len = Math.max(len1, len2);
  String newstring = "";
  for (int i = 0; i < max_len; i++) 
  {
    if (i <= len1-1)
      newstring += stng1.substring(i,i+1);
    if (i <= len2-1)
      newstring += stng2.substring(i,i+1);
  }
  return newstring;
}

================================================================================================================

 Check whether a specified character is happy or not :=  /// 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   A character is happy when the same character appears to its left or right in a string
   
   
     for (int i = 0; i < l; i++) 
  {
    if (stng.charAt(i) == 'z') 
	{
      if (i > 0 && stng.charAt(i-1) == 'z')
        char_happy = true;
      else if (i < l-1 && stng.charAt(i+1) == 'z')
        char_happy = true;
      else
        char_happy = false;
    }
  }


================================================================================================================

 Print last 3 Characters 3 Times :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  int l = stng.length();
  String new_word = "";
  for (int i = 0; i < no_repeat; i++) 
  {
    new_word += stng.substring(l - no_repeat, l);
  }
  return new_word;
}

================================================================================================================

 Count number of words ending in 'm' or 'n' in given text  :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  for (int i = 0; i < l; i++) 
  {
    if (stng.charAt(i) == 'm' || stng.charAt(i) == 'n') 
	{
      if (i < l-1 && !Character.isLetter(stng.charAt(i+1)))
        ctr++;
      else if (i == l-1)
        ctr++;
    }
  }
  return ctr;
}

================================================================================================================

 return the sum of the digits present in the given string :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  int l = stng.length();
  int sum = 0;
  for (int i = 0; i < l; i++) 
  {
    if (Character.isDigit(stng.charAt(i))) 
	{
      String tmp = stng.substring(i,i+1);
      sum += Integer.parseInt(tmp);
    }
  }
  return sum;

================================================================================================================

   First Non Repeated Character in String  :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		String str = "aabbcd";

		for (int i = 0; i < str.length(); i++) {
			boolean unique = true;
			for (int j = 0; j < str.length(); j++) {
				if (i != j && str.charAt(i) == str.charAt(j)) {
					unique = false;
					break;
				}
			}
			if (unique) {
				System.out.println("First Repeated Character is " + str.charAt(i));
				break;
			}
		}
		
===================================
 HashMap<Character,Integer>  characterhashtable =  new HashMap<Character ,Integer>();
     
    	 int i,length ; Character c ;
        length= str.length();  // Scan string and build hash table
        for (i=0;i < length;i++)
        {
            c=str.charAt(i);
            if(characterhashtable.containsKey(c))
            {
                // increment count corresponding to c
                characterhashtable.put(  c ,  characterhashtable.get(c) +1 );
            }
            else
            {
                characterhashtable.put( c , 1 ) ;
            }
        }
        // Search characterhashtable in in order of string str
        
        for (i =0 ; i < length ; i++ )
        {
            c= str.charAt(i);
            if( characterhashtable.get(c)  == 1 )
            System.out.println("First Repeated Character is " + str.charAt(i));
        }
		
		 for (char c : strArray)
        {
            if (charCountMap.get(c) > 1)
            {
                System.out.println("First Repeated Character In '"+inputString+"' is '"+c+"'");       
                break;
            }
        }
        
    }
		
============================================================================

 Find Number Of Characters, Words And Lines In A File :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        int charCount = 0, wordCount = 0, lineCount = 0;
         
        try
        {
            //Creating BufferedReader object
             
            reader = new BufferedReader(new FileReader("C:\sample.txt"));
             
            //Reading the first line into currentLine
             
            String currentLine = reader.readLine();
             
            while (currentLine != null)
            {
                //Updating the lineCount
                 
                lineCount++;
                 
                //Getting number of words in currentLine
                 
                String[] words = currentLine.split(" ");
                 
                //Updating the wordCount
                 
                wordCount = wordCount + words.length;
                 
                //Iterating each word
                 
                for (String word : words)
                {
                    //Updating the charCount
                     
                    charCount = charCount + word.length();
                }
                 
                //Reading next line into currentLine
                 
                currentLine = reader.readLine();
            }
             
            //Printing charCount, wordCount and lineCount
             
            System.out.println("Number Of Chars In A File : "+charCount);
             
            System.out.println("Number Of Words In A File : "+wordCount);
             
            System.out.println("Number Of Lines In A File : "+lineCount);
			
=================================================================================================

 Most Repeated Character in String  :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            Set<Entry<String, Integer>> entrySet = wordCountMap.entrySet();
             
            for (Entry<String, Integer> entry : entrySet)
            {
                if(entry.getValue() > count)
                {
                    mostRepeatedWord = entry.getKey();
                     
                    count = entry.getValue();
                }
            }
             
            System.out.println("The most repeated word in input file is : "+mostRepeatedWord);
             
            System.out.println("Number Of Occurrences : "+count);
			
=================================================================================================			

 Sort Strings in Alphabetical Order :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
      for (int i = 0; i < count; i++) 
        {
            for (int j = i + 1; j < count; j++) { 
                if (str[i].compareTo(str[j])>0) 
                {
                    temp = str[i];
                    str[i] = str[j];
                    str[j] = temp;
                }
            }
        } 
		
============================================================================

 Bubble Sort :=
~~~~~~~~~~~~~~~
 
 	String str[] = { "Ajeet", "Steve", "Rick", "Becky", "Mohan"};
	String temp;
	System.out.println("Strings in sorted order:");
	for (int j = 0; j < str.length; j++) {
   	   for (int i = j + 1; i < str.length; i++) {
		// comparing adjacent strings
		if (str[i].compareTo(str[j]) < 0) {
			temp = str[j];
			str[j] = str[i];
			str[i] = temp;
		}
	   }
	   System.out.println(str[j]);
	}
	
============================================================================	

         String s1="Keep", s2="Peek" ;
         String s1 = str1.replaceAll("\\s", "");  
         String s2 = str2.replaceAll("\\s", "");  
        boolean status = true;  
        if (s1.length() != s2.length()) {  
            status = false;  
        } else {  
            char[] ArrayS1 = s1.toLowerCase().toCharArray();  
            char[] ArrayS2 = s2.toLowerCase().toCharArray();  
            Arrays.sort(ArrayS1);  
            Arrays.sort(ArrayS2);  
            status = Arrays.equals(ArrayS1, ArrayS2);  
        }  
        if (status) {  
            System.out.println(s1 + " and " + s2 + " are anagrams");  
        } else {  
            System.out.println(s1 + " and " + s2 + " are not anagrams");  
        }
	
============================================================================

 Reverse Each Word Of A String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   String[] words = inputString.split(" ");
         
        String reverseString = "";
         
        for (int i = 0; i < words.length; i++) 
        {
            String word = words[i];
             
            String reverseWord = "";
             
            for (int j = word.length()-1; j >= 0; j--) 
            {
                reverseWord = reverseWord + word.charAt(j);
            }
             
            reverseString = reverseString + reverseWord + " ";
        }
		
==============================================================================
 
  Reverse each Word in given String  :=  (***********)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    String words[]=str.split("\\s");  
    String reverseWord="";  
    for(String w:words){  
        StringBuilder sb=new StringBuilder(w);  
        sb.reverse();  
        reverseWord+=sb.toString()+" ";  
    }  
    return reverseWord.trim();  
	
==============================================================================

 Frequency of Character in Given String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       int i=str.length(); char c;
	   
        for(c='A'; c<='z'; c++)
        {
            k=0;
            for(j=0; j<i; j++)
            {
                ch = str.charAt(j);
                if(ch == c)
                {
                    k++;
                }
            }
            if(k>0)
            {
                System.out.println("The character " + c + " has occurred for " + k + " times");
            }
        }

		
======================================================================================================

 Swap Two Strings :=
~~~~~~~~~~~~~~~~~~~
         s1 = s1 + s2;
         
        s2 = s1.substring(0, s1.length()-s2.length());
         
        s1 = s1.substring(s2.length());
		
======================================================================================================

 Longest SubString in Given String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    public int lengthOfLongestSubstring(String s) {
        // Note: The Solution object is instantiated only once and is reused by each test case.
        int maxLength = 0;
        
        for(int i = 0; i < s.length(); i++) {
            HashSet<Character> chars = new HashSet<Character>();
            chars.add(s.charAt(i));
            int j = i + 1;
            while(j < s.length()) {
                if(chars.contains(s.charAt(j))) {
                    break;
                }
                else {
                    chars.add(s.charAt(j));
                    j++;
                }
            }
            if(chars.size() > maxLength) {
                maxLength = chars.size();
            }
        }
        
        return maxLength;
    }
	
======================================================================================================	

 Print Duplicate Characters from Strings :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		
		String str = "Rama";
		int count = 0;
		char string[] = str.toCharArray();

		System.out.println("Duplicate characters in a given string: ");
		for (int i = 0; i < string.length; i++) {
			count = 1;
			for (int j = i + 1; j < string.length; j++) {
				if (string[i] == string[j] && string[i] != ' ') {
					count++;
					//string[j] = '0';
				}
			}
			if (count > 1 && string[i] != '0')
				System.out.print(string[i]+" ");
		}
		
======================================================================================================

 Remove Duplicate Characters from Strings :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		String string = "aabbccdefatafaz";
		char[] chars = string.toCharArray();
		Set<Character> charSet = new LinkedHashSet<Character>();
		for (char c : chars) {
			charSet.add(c);
		}

		StringBuilder sb = new StringBuilder();
		for (Character character : charSet) {
			sb.append(character);
		}
		System.out.println(sb.toString());
		
=================================================================================================

 Print Repeated Character form String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		str = "ramakri";
		i = str.length();
		for (c = 'A'; c <= 'z'; c++) {
			k = 0;
			for (j = 0; j < i; j++) {
				ch = str.charAt(j);
				if (ch == c) {
					k++;
				}
			}
			if (k > 0) {
				System.out.println("The character " + c + " has occurred for " + k + " times");
			}
		}
		
===========================================================

 All SubString in given String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		String str = "abcd";

		for (int i = 0; i < str.length(); i++) {
			for (int j = i + 1; j < str.length(); j++) {

				System.out.println(str.substring(i, j));
			} 
	

====================================================================================================

 Maximum Repeated Character in String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	char[] charArray = inputString.replaceAll("\s+", "").toCharArray();
         
        for (char c : charArray) 
        {
            if (charCountMap.containsKey(c))
            {
                charCountMap.put(c, charCountMap.get(c)+1);
            }
            else
            {
                charCountMap.put(c, 1);
            }
        }
		
	    Set<Entry<Character, Integer>> entrySet = charCountMap.entrySet();
         
        int maxCount = 0;
         
        char maxChar = 0;
         
        for (Entry<Character, Integer> entry : entrySet) 
        {
            if (entry.getValue() > maxCount)
            {
                maxCount = entry.getValue();
                 
                maxChar = entry.getKey();
            }
        }
	
         
        System.out.println("Input String : "+inputString);
         
        System.out.println("Maximum Occurring char and its count :");
         
        System.out.println(maxChar+" : "+maxCount);
		
==============================================================================================

 find any word that contains all the given characters at least once :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
String word = "dog";
    String  dictionaryWord;
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    while((dictionaryWord = br.readLine()) != null)  {
        Set<Character> chars = new HashSet<Character>();
        for (char c : word.toCharArray()) {
            chars.add(c);
        }
        boolean match = true;
        for (Character c : chars) {
            String s = "" + c;
            if (!dictionaryWord.contains(s)) {
                match = false;
                break;
            }
        }
        if (match == true) 
            System.out.println(dictionaryWord);
    }
	
==============================================================================================
 
 First Non Repeated Character form String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		String str = "aabbcd";

		for (int i = 0; i < str.length(); i++) {
			boolean unique = true;
			for (int j = 0; j < str.length(); j++) {
				if (i != j && str.charAt(i) == str.charAt(j)) {
					unique = false;
					break;
				}
			}
			if (unique) {
				System.out.println("First Repeated Character is " + str.charAt(i));
				break;
			}
		}
		
=====================================================================

  Second Most Repeated Character in String :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   		String s = "aaaaaabbbbc";
		int a[] = new int[255];
		int fmax = 0;
		int smax = 0;
		char res = ' ';
		for (int i = 0; i < s.length(); i++) {

			int m = s.charAt(i);

			a[m]++;

		}
		for (int k = 0; k < a.length; k++) {
			if (a[k] > 0) {

				if (a[k] > fmax) {
					fmax = a[k];
				}
				if (a[k] != fmax && a[k] > smax) {
					smax = a[k];
					res = (char) k;
				}
			}
		}
		System.out.println(res + "..." + fmax);
	}		

===========================================================================================

 Print the string after the specified character has occurred given no. of times :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
	package com.demo.example;

public class GFG {

	static void printString(String str, char ch, int count) 
    { 
        int occ = 0, i; 
       
        // If given count is 0 
        // print the given string and return 
        if (count == 0) { 
            System.out.println(str); 
            return; 
        } 
       
        // Start traversing the string 
        for (i = 0; i < str.length(); i++) { 
       
            // Increment occ if current char is equal 
            // to given character 
            if (str.charAt(i) == ch) 
                occ++; 
       
            // Break the loop if given character has 
            // been occurred given no. of times 
            if (occ == count) 
                break; 
        } 
       
        // Print the string after the occurrence 
        // of given character given no. of times 
        if (i < str.length() - 1) 
            System.out.println(str.substring(i + 1)); 
       
        // Otherwise string is empty 
        else
            System.out.println("Empty string"); 
    } 
      
    // Driver Method 
    public static void main(String[] args) 
    { 
        String str = "geeks for geeks"; 
        printString(str, 'e', 2); 
    } 
}
	
		
=======================================(CollectionsLogicalPrograms)===================================================

 Sort elements in Map by using Values :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		List<Map.Entry<String, Integer>> list = new LinkedList<Map.Entry<String, Integer>>(hm.entrySet());
		// Sort the list
		Collections.sort(list, new Comparator<Map.Entry<String, Integer>>() {
			public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
				return (o1.getValue()).compareTo(o2.getValue());
			}
		});

		// put data from sorted list to hashmap
		HashMap<String, Integer> temp = new LinkedHashMap<String, Integer>();
		for (Map.Entry<String, Integer> aa : list) {
			temp.put(aa.getKey(), aa.getValue());
		}

       /// Printing Map 
		for (Map.Entry<String, Integer> en : temp.entrySet()) {
			System.out.println("Key = " + en.getKey() + ", Value = " + en.getValue());
		}

======================================================================================================================
 
 DeadLock in Java :=
~~~~~~~~~~~~~~~~~~~~

    String str1 = "Java";
    String str2 = "UNIX";
     
    Thread trd1 = new Thread("My Thread 1"){
        public void run(){
            while(true){
                synchronized(str1){
                    synchronized(str2){
                        System.out.println(str1 + str2);
                    }
                }
            }
        }
    };
     
    Thread trd2 = new Thread("My Thread 2"){
        public void run(){
            while(true){
                synchronized(str2){
                    synchronized(str1){
                        System.out.println(str2 + str1);
                    }
                }
            }
        }
    };
     
    public static void main(String a[]){
        MyDeadlock mdl = new MyDeadlock();
        mdl.trd1.start();
        mdl.trd2.start();
    }
}		
=======================================================================================================================

 FileHandling880 :=
~~~~~~~~~~~~~~~~~~

    BufferedReader reader =  new BufferedReader(new FileReader("C:\sample.txt"));
	
	
	
=======================================================================================================================

 Alogorithms880 :=
~~~~~~~~~~~~~~~~~
 --- Defined as FINITE sequence of Steps to solve a PROBLEM . 
 --- Used at designing level.
 --- Written by designer(Architect) having Domain-Knowledge.
 --- Algorithms are Analyzed for better Outcome. 


 Programs :=
~~~~~~~~~~~
 --- Used at Implementing Design,
 --- Written by Programmers
 --- Programs are need to Tested.
 
 

 "C:\Program Files\MongoDB\Server\4.4\bin\mongo.exe"


================================================================================================================
 
 SortingTechniques :=  [ https://github.com/greenlearner01/Searching-and-Sorting/tree/master/src/com/gl/searching ]
~~~~~~~~~~~~~~~~~~~~~ 

    O(n) //// O(n2) [Worst] //// O(1) [Worst] //// O(n)  [Best]


 O(1) -------->  performance is not affected by the size of the input data.
 
 O(N) -------->  This algorithm will take more time as number of elements in input data increases.
                This algorithm whose performance is directly proportional to size of the input data.
				
 O(N^2)  -----> This  an algorithm whose performance is directly proportional to square of the size of the input data.				
				
 O(log N) ----> This algorithms whose execution time grows linearly as input data grows exponentially	//// uses divide and conquer rule to search for an element.			
				
 O(2N) -------> This  algorithm whose execution time is doubled for every extra element in the input data.				
				
O(N!) -----> This  algorithm which has to perform N! computations to solve a problem. Where N is the number of elements in the input data. For example



 (1) Bubble Sort  :=  O(n²) 
~~~~~~~~~~~~~~~~~~
 --- Sorts elements either in ASC/DESC by comparing ADJACENT elements.
 --- If 'n' elements are present , then we need (n-1) PASSES to Sort. 
		 
 
  Logic ::
  ------
       for(i=0; i<(n-1); i++)
       {
           for(j=0; j<(n-i-1); j++)
           {
               if(arr[j] > arr[j+1])
               {
                   temp = arr[j];
                   arr[j] = arr[j+1];
                   arr[j+1] = temp;
               }
           }
       }
  	
				
				O(log n)  >   O(n)  > O(n2)
	
=======================================================	
	
 (2) Selection  Order := O(n²) 
~~~~~~~~~~~~~~~~~~~~~~~
 --- It is Slow Because Compares with each element.  	


      for(i=0; i<(size-1); i++)
      {
         small = arr[i];
         for(j=(i+1); j<size; j++)
         {
            if(small>arr[j])
            {
               small = arr[j];
               count++;
               index = j;
            }
         }
         if(count!=0)
         {
            temp = arr[i];
            arr[i] = small;
            arr[index] = temp;
         }
         count=0;
      }
	  
	

 (2) Insertion Order :=  O(n²) 
~~~~~~~~~~~~~~~~~~~~~~~
 
  void sort(int arr[])
    {
        int n = arr.length;
        for (int i = 1; i < n; ++i) {
            int key = arr[i];
            int j = i - 1;
 
            /* Move elements of arr[0..i-1], that are
               greater than key, to one position ahead
               of their current position */
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
    }



 (3) Selection Order :=
~~~~~~~~~~~~~~~~~~~~~~~
 ---

=================================================
 
 SearchAlgorithm :=  [ https://github.com/greenlearner01/Searching-and-Sorting/tree/master/src/com/gl/searching ]
~~~~~~~~~~~~~~~~~~

 Binary Search :=
~~~~~~~~~~~~~~~~
 --- Faster than Linear Search 
 --- Searches elements from given element in array


 Linear Search :=
~~~~~~~~~~~~~~~~~
	
===========================================================================================================		
		
 Fabinnaci Seies :=  // Storing  SUM && PREVIOUS values 
~~~~~~~~~~~~~~~~~~
		int num = 5;
		     //    <------
		int n1 = 0, n2 = 1, sum = 0;
		for (int i = 0; i < num; i++) {

			System.out.print(n1 + " ");
			sum = n1 + n2;
			n1 = n2;
			n2 = sum;
		}

============================================================================================================		

 DataStructures :=   ( YOUTUBE ----> Naresh-IT ///  Sandeep-Saradhy ///  Jenny ///  Programming with Mosh )  
~~~~~~~~~~~~~~~~~~ 
	Primitive DS ---->  int, float, long, byte 

  Non-Primitives DS ---->    (A)  Linear                    (B) Non-Linear 
 
                       Arrays66, List34, Stack55, Queues90           Trees, Graphs 
	
	                   LinkedList90 , CircularLinkedList50

             Operations Performed ---> Searching
			                           Sorting
									   Insertion 
                                       Deletion	
                                       Updation 
 
  Notations :=
~~~~~~~~~~~~~

  O(1) -------> Accessing  elements using Indexes ///  If Element Found at First Index

  O(n) -------> Insertion / Deletion of elements using Indexes	(Linear-Curve) //// Delete element of array  (Worst-Case)
                                                       
													    If Element Found at Last Index
   

  O(n2) ------> 2 Nested For-Loop   ////   O(n3) ---> 3 Nested For-Loop

  O(log n) --->  Slower than O(n)  //// 
  
  O(2n) ------>  Opposite to  O(log n) .
  
  
 


 Arrays66 :=
~~~~~~~~~~~~
 --- Can Access any elements Random using INDEX.
 --- Static Memory Allocation 

===========================================

 LinkedList90 :=	/// Memory allocated using 'malloc' function  /// Head && Tail  
~~~~~~~~~~~~~~~~~
 --- No Wastage of Memory 
 --- No need to Continious Memory Locations 
 ---Insertion && Deletion is very easy ///    Stack && Queue can be easily implemented 
 --- Random Access is not Possible (****)
 --- Reversing the Linked-List is Complex (***)
 
           Node ----> (1) Data && (2) Address of next Node  /// Last Node will have "NULL" in Address  

===========================================

  CircularLinkedList50 :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~
 --- Last Node will conatin  Address of First Node (****)		
		
		
============================================================================================================

 SearchAlgorithm660 :=  (******* YOUTUBE ---> SANDEEP SARATHI **********)
~~~~~~~~~~~~~~~~~~~~~~ 

 (1) Linear Search :=
~~~~~~~~~~~~~~~~~~~~
 --- Compares Given element with every element in Array.
 
  
  public static int search(int arr[], int x)
    {
        int n = arr.length;
        for (int i = 0; i < n; i++)
        {
            if (arr[i] == x)
                return i;
        }
        return -1;
    }



 (2) Binary Search :=  
~~~~~~~~~~~~~~~~~~~~
 --- Takes 'Low' && 'High' values and Divide by '2'.
 
  	
	
============================================================================================================

  SingletonDemoEg :=
~~~~~~~~~~~~~~~~~~~
package com.demo.example;


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;


public class JDBCSingleton {

	 
    
 //Step 1
       
      // create a JDBCSingleton class.


     //static member holds only one instance of the JDBCSingleton class.
           
         private static JDBCSingleton jdbc;
         
     //JDBCSingleton prevents the instantiation from any other class.
         private JDBCSingleton() {  }
      
    //Now we are providing gloabal point of access.
          
         public static JDBCSingleton getInstance() {  
                                     if (jdbc==null)
                                   {
                                            jdbc=new   
                                      JDBCSingleton();
                                   }
                         return jdbc;
             }
          
   // to get the connection from methods like insert, view etc. 
          private static Connection getConnection()throws ClassNotFoundException, SQLException
          {
              
              Connection con=null;
              Class.forName("com.mysql.jdbc.Driver");
              con= DriverManager.getConnection("jdbc:mysql://localhost:3306/ashwanirajput", "root", "ashwani");
              return con;
              
          }
          
 //to insert the record into the database 
          public int insert(String name, String pass) throws SQLException
          {
              Connection c=null;
              
              PreparedStatement ps=null;
              
              int recordCounter=0;
              
              try {
                  
                      c=this.getConnection();
                      ps=c.prepareStatement("insert into userdata(uname,upassword)values(?,?)");
                      ps.setString(1, name);
                      ps.setString(2, pass);
                      recordCounter=ps.executeUpdate();
                      
                      
              } catch (Exception e) {
                  
                  e.printStackTrace();
                  
              } finally{
                    
                  if (ps!=null){
                      ps.close();
                  }if(c!=null){
                      c.close();
                  } 
                  
              }
              
             return recordCounter;
          }

//to view the data from the database      
      public  void view(String name) throws SQLException
      {
                Connection con = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
                
                try {
                    
                        con=this.getConnection();
                        ps=con.prepareStatement("select * from userdata where uname=?");
                        ps.setString(1, name);
                        rs=ps.executeQuery();
                        while (rs.next()) {
                                  System.out.println("Name= "+rs.getString(2)+"\t"+"Paasword= "+rs.getString(3));    
                       
                        }
                    
              
          } catch (Exception e) {
                    System.out.println(e);
              
          }finally{
                    if(rs!=null){
                        rs.close();
                    }if (ps!=null){
                      ps.close();
                  }if(con!=null){
                      con.close();
                  } 
                    
                }
      }
      
// to update the password for the given username
      public int update(String name, String password) throws SQLException
      {
              Connection c=null;
              
              PreparedStatement ps=null;
              
              int recordCounter=0;
              
              try {
                  
                      c=this.getConnection();
                      ps=c.prepareStatement(" update userdata set upassword=? where uname='"+name+"' ");
                      ps.setString(1, password);
                      recordCounter=ps.executeUpdate();
                      
                      
              } catch (Exception e) {
                  
                  e.printStackTrace();
                  
              } finally{
                    
                  if (ps!=null){
                      ps.close();
                  }if(c!=null){
                      c.close();
                  } 
                  
              }
              
             return recordCounter;
          }
          
// to delete the data from the database 
         public int delete(int userid) throws SQLException
      {
              Connection c=null;
              
              PreparedStatement ps=null;
              
              int recordCounter=0;
              
              try {
                  
                      c=this.getConnection();
                      ps=c.prepareStatement(" delete from userdata where uid='"+userid+"' ");
   
                      recordCounter=ps.executeUpdate();
                      
                      
              } catch (Exception e) {
                  
                  e.printStackTrace();
                  
              } finally{
                    
                  if (ps!=null){
                      ps.close();
                  }if(c!=null){
                      c.close();
                  } 
                  
              }
              
             return recordCounter;
          }
            
          
     
    
 }// End of JDBCSingleton class
 
============================================

package com.demo.example;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class JDBCSingletonDemo {
	  static int count=1;
	    static int  choice;
	    public static void main(String[] args) throws IOException {
	        
	        JDBCSingleton jdbc= JDBCSingleton.getInstance();
	        
	        
	        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	   do{ 
	        System.out.println("DATABASE OPERATIONS");
	        System.out.println(" --------------------- ");
	        System.out.println(" 1. Insertion ");
	        System.out.println(" 2. View      ");
	        System.out.println(" 3. Delete    ");
	        System.out.println(" 4. Update    ");
	        System.out.println(" 5. Exit      ");
	        
	        System.out.print("\n");
	       
	        
	        System.out.print("Please enter the choice what you want to perform in the database: ");
	        
	        choice=Integer.parseInt(br.readLine());
	        
	        switch(choice)
	       {
	            
	           case 1:{
	                    System.out.print("Enter the username you want to insert data into the database: ");
	                    String username=br.readLine();
	                    System.out.print("Enter the password you want to insert data into the database: ");
	                    String password=br.readLine();
	                    
	                    try {
	                            int i= jdbc.insert(username, password);
	                            if (i>0) {
	                            System.out.println((count++) + " Data has been inserted successfully");
	                            }else{
	                                System.out.println("Data has not been inserted ");    
	                            }
	                        
	                        } catch (Exception e) {
	                          System.out.println(e);
	                        }
	                    
	                     System.out.println("Press Enter key to continue...");
	                     System.in.read();
	                     
	                   }//End of case 1
	                   break;
	            case 2:{
	                    System.out.print("Enter the username you want to view the entire data from the database: ");
	                    String username=br.readLine();
	             
	                    try  {
	                            jdbc.view(username);
	                         } catch (Exception e) {
	                          System.out.println(e);
	                        }
	                     System.out.println("Press Enter key to continue...");
	                     System.in.read();
	                     
	                   }//End of case 2
	                  break;
	             case 3:{
	                     System.out.print("Enter the userid for which you want to delete the entire data from the database: ");
	                     int userid=Integer.parseInt(br.readLine());
	           
	                     try {
	                            int i= jdbc.delete(userid);
	                            if (i>0) {
	                            System.out.println((count++) + " Data has been deleted successfully");
	                            }else{
	                                System.out.println("Data has not been deleted");    
	                            }
	                        
	                         } catch (Exception e) {
	                          System.out.println(e);
	                         }
	                     System.out.println("Press Enter key to continue...");
	                     System.in.read();
	                     
	                    }//End of case 3
	                   break;
	             case 4:{
	                    System.out.print("Enter the username for which  you want to update the data into the database: ");
	                    String username=br.readLine();
	                    System.out.print("Enter the new password ");
	                    String password=br.readLine();
	                    
	                    try {
	                            int i= jdbc.update(username, password);
	                            if (i>0) {
	                            System.out.println((count++) + " Data has been updated successfully");
	                            }
	                        
	                        } catch (Exception e) {
	                          System.out.println(e);
	                        }
	                     System.out.println("Press Enter key to continue...");
	                     System.in.read();
	                    
	                   }// end of case 4
	                 break;
	                 
	             default:
	                     return;
	        }
	        
	       } while (choice!=4); 
	       
	    
	  }

}

===================================================================================================================
 
 Print Middle Node in Linked List  :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static Node head;

	// Link list node
	class Node {
		int data;
		Node next;

		// Constructor
		public Node(Node next, int data) {
			this.data = data;
			this.next = next;
		}
	}
	
	//=========================================================
	
	
	void push(Node head_ref, int new_data) {

		// Allocate node
		Node new_node = new Node(head_ref, new_data);

		// Move the head to point to the new node
		head = new_node;
	}

	// =========================================================
 
	
	// A utility function to print a
	// given linked list
	void printList(Node head) {
		while (head != null) {
			System.out.print(head.data + "-> ");
			head = head.next;
		}
		System.out.println("null");
	}
	
	//=========================================================

	// Function to get the middle of
	// the linked list
	void printMiddle(Node head) {
		int count = 0;
		Node mid = head;

		while (head != null) {

			// Update mid, when 'count'
			// is odd number
			if ((count % 2) == 1)
				mid = mid.next;

			++count;
			head = head.next;
		}

		// If empty list is provided
		if (mid != null)
			System.out.println("The middle element is [" + mid.data + "]\n");
	}

	// =========================================================

	

	// Driver code
	public static void main(String[] args) {
		GFG ll = new GFG();

		for (int i = 3; i > 0; i--) {
			ll.push(head, i);
			ll.printList(head);
			ll.printMiddle(head);
		}
	}

	// =========================================================


=========================================================================================================
