


        .....LAMBDAEXPRESSIONS123....FUNCTONALINTERFACE123.........METHODREFERENCE123
   
        .....DEFAULTMETHOD123........STREAMS123.....OPTIONAL123....StringJoiner890....ForEach990
		
		.....ComparatorInJava........Predicate335........MultipleInheritance555..........LocalDateTime3430
	  
	     ....OthersFeatureINJava (**)........
	
	  https://www.concretepage.com/java/java-8/
	  https://www.java2novice.com/java-8/
	  https://github.com/amigoscode/java-functional-programming
	  
	  https://github.com/RameshMF/java-8-tutorial/tree/master/src/com/ramesh/java8
	  https://github.com/codecentric/java8-examples/tree/master/src/main/java/de/codecentric/java8examples
	  
	  https://javaconceptoftheday.com/solving-real-time-queries-using-java-8-features-employee-management-system/
	  
	  https://github.com/Java-Techie-jt/java8 (****)
      
	
 Java 7 :=
~~~~~~~~~~
 --- Try with Resource) ----> Avoids Memory Leaks      //////  Eg :: Files .
 --- Underscore for Numeric Literals (Between Digits)
 --- String in Switch-case. (Case-Sensitive)
 --- Catching Multiple Exceptions in catch Block

 Java 8 :=
~~~~~~~~
 --- Released in 2014.
 
 
 ParllelStreams :=
~~~~~~~~~~~~~~~~
 --- Doesn’t care about the order. //// The performance is high.
 
 Eg:= list.parallelStream().filter(str->str.length()>3).map(String::toUpperCase).sorted().forEach(System.out::println);;    
~~~~~


 Primitive type in Stream := InstStream , LongStream , DoubleStream . 
~~~~~~~~~~~~~~~~~~~~~~~~~~


 Functional programming :=
~~~~~~~~~~~~~~~~~~~~~~~~~
 --- It is a way of thinking about software construction by creating pure functions. 
 --- Functions provide better modularity for your application and a high degree of code reusing.
 

 Functional Vs Object-Oriented programming :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 --- Both Functional programming and object-oriented programming uses a different method for storing and manipulating the data. 
 --- In functional programming, data cannot be stored in objects and it can only be transformed by creating functions.
 --- In object-oriented programming, data is stored in objects.


	
=================/\/\\/\/\===============/\/\/\/\/\/\/\/\===============/\/\/\/\/\/\/\/\=============

======================================================================================================

 LAMBDAEXPRESSIONS123 :=  [ https://www.javaguides.net/2018/07/java-8-lambda-expressions.html ]
~~~~~~~~~~~~~~~~~~~~~~~~  [ https://github.com/kishanjavatrainer?tab=repositories&q=lambda&type=&language= ]

                          [ https://github.com/koushikkothagal/Java-8-Lambda-Basics ]                        
    				      [ https://github.com/koushikkothagal/Java-8-Lambda-Basics/tree/master/src/io/javabrains ]



        Implementing Interface && Not Class . 
 
--->Lambda Expression is an anonymous function which accepts a set of input parameters and returns results. (or) passed (mostly) to other functions as parameters. 


--->A Lambda Expression contains 3 parts:
Parameter List:= A Lambda Expression can contain zero or one or more parameters. It is optional.
Lambda Arrow Operator:= “->” is known as Lambda Arrow operator. It separates parameters list and body.
Lambda Expression Body

 Lambda Expression does not need :: Method --->  Acces-Modifer, 
                                                 Return-Type, 
												 Method-Name &&
												 Arguments-DataType (********) 

  Eg :=
~~~~
	private static void createThreadUsingLamdaExpression() {
		Runnable r=	()-> {System.out.println("My task is executing..");};
		Thread thread = new Thread(r);
		thread.start();
	}

	private static void createThreadUsingAnonymousClass() {
		Runnable r=	new Runnable() {
			@Override
			public void run() {
				System.out.println("My task is executing..");
			}
		};
		
		Thread thread = new Thread(r);
		thread.start();
	} 

 Handling Exceptions In Lambda Expression :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	private static void createThreadUsingAnonymousClass() {
	    try{
		Runnable r=	new Runnable() {
			@Override
			public void run() {
				System.out.println("My task is executing..");
			}
		};
		
		Thread thread = new Thread(r);
		thread.start();
		}catch(Exception e){
		  System.out.println(e);
	  }	
	} 
================

  LM := [ https://github.com/kishanjavatrainer/LambdaWithFunctionalInterfaces ]
-----
 --- [()] && [{}] are Optional fro Single-Parameter && Single-Line . 
 
 Methods should be ::
~~~~~~~~~~~~~~~~~~~~
     void demo();
	 
	 void method2(String name);
	 
	 void method3(String name,int age);

 Eg :=
~~~~~
     
 @FunctionalInterface
 public interface MyInterface1 {
	public abstract void method1();
 }

public class ClientTest {

	public static void main(String[] args) {
		
		MyInterface1 myInterface1=()->System.out.println("This methods executes using lambda..");
		myInterface1.method1();
		
		System.out.println("-----------------------------");
		
		MyInterface2 myInterface2=name->System.out.println("Your name is:"+name);
		myInterface2.method2("Sean Murphy");
		
		System.out.println("-----------------------------");
		
		MyInerface3 myInerface3=(name,age)->{
			System.out.println("Your name is:"+name);
			System.out.println("You are "+age+" years Old..");
		};
		
		myInerface3.method3("Andrew", 30);
		
	   System.out.println("-----------------------------");
	
	}

}

 Lambda with RETURN-TYPE := Method -- "RETURN" is also not required 
~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 @FunctionalInterface
  public interface MyInterface {
    boolean test(int n1,int n2);
 }

 public class ClientTest {

	public static void main(String[] args) {
		
		MyInterface myInterface=(n1,n2)->n1>n2;
		System.out.println(myInterface.test(40, 35));
	}
}



 try catch inside Lambda :=
~~~~~~~~~~~~~~~~~~~~~~~~~

(String s) -> {
    try {
        return myMethod(s);
    } catch (IOException ex) {
        throw new RuntimeException(ex);
        // (Or do something else with it...)
    }
}

------------

 List<String> integers = Arrays.asList("44", "373", "xyz", "145");
 integers.forEach(str -> {
    try {
        System.out.println(Integer.parseInt(str));
    }catch (NumberFormatException ex) {
        System.err.println("Can't format this string");
    }
  }
 ); 


================
	
--->This Lambda Expression does not have parameters and does return any results. So it’s type is “java.lang.Runnable” Functional Interface.

--->A lambda expression is an instance of a functional interface. (********) 

--->functional programming is not a part of Object (In Isolation), So "-Public-" is not required


 Eg1 :=
~~~~~~
  interface ABCInter { int addNum(int a, int b); }
  
  Class Demo{
          Main{
     
    ABCInter lam=(int a, int b) -> a+b; .........//LambdaExpression, Error Occurs when change in Method-Arguments.

-----------------------------------------------

        Sayable sayable = (msg) - > {
            System.out.println(msg);
        };
        sayable.say("Say something ..");
		
		
=================/\/\\/\/\===============/\/\/\/\/\/\/\/\===========/\/\/\/\/\/\/\/\=============

======================================================================================================
 
FUNCTONALINTERFACE123 (I) :=   [ https://www.javaguides.net/2018/07/java-8-functional-interfaces.html ]
~~~~~~~~~~~~~~~~~~~~~~  
 
 [ https://github.com/amigoscode/java-functional-programming/tree/master/src/main/java ]
 [ https://github.com/kishanjavatrainer?tab=repositories&q=functional&type=&language= ]
 [ https://github.com/kishanjavatrainer/FunctionalInterfaceWithLamda ]
 
 
  BiConsumerInterface  :=
~~~~~~~~~~~~~~~~~~~~~~~~
 --- Takes 2 Input Argement && Return Result. 
 
  
  BiPredicate Interface  :=
~~~~~~~~~~~~~~~~~~~~~~~~
 --- Takes 2 Input Argement && Return Boolean.  
 
 

        Functional Interface
                       		 ----> Comparator, Comaparable,
                       		 ----> Callable(java.util.concurrent.Callable), Runnable(java.lang.Runnable) 
                       Java-8 ---> predicate, Supplier, Consumer


 4-Types := [ Youtube ---> Play-Java ] ///  [ import java.util.* ] /// [ https://github.com/Java-Techie-jt/java8 ]
~~~~~~~~~~    
      [ https://github.com/Java-Techie-jt/java8/tree/master/demo ]      
	  
  --- Predicate(Returns Boolean value)...............test(str))   ////  'filter'
  --- Function (Has Input and Output)                            ////   
  --- Consumer (Only Input and  No  Output)                     ////   'forEach'  
  --- Supplier (No Input and Only Output)                      //// 

  --- Predicate(Returns Boolean value)......................   ///  test(T t)       //       String.Length Check 
  --- Function (Has Input and Outputs of Data) )...........   ///  apply(T t)      //    Takes 2*10 as I/p && Print Output
  --- Consumer (Has Input and No Output Data) .............  ///   accept(T t)    //  Takes Employee-Name as I/p && Print O/P
  --- Supplier (No Inputs Data and Only Output)...........  ///     get()        //         String.Length Check 


================

 (Q) Use of Functional-Interface
 (A) wrap a function as an interface. The function is represented by the single abstract method on the interface.
 
 (Q) What is Consumer Chaining ??
 (A) using "andThen()" && "apply()" method, Connecting mutiple Consumers. 

=================

---> Al methods not Thorws Exception. 

--->contains only one abstract method. These interfaces are also called Single Abstract Method interfaces (SAM Interfaces).Functional interfaces were introduced in Java 8 in order to implement lambda expressions.

--->In Java 8, functional interfaces can be represented using lambda expressions, method reference and constructor references as well.

--->Before Java 8, Functional-Interfaces can be represented as Comparable, Comparator. (****************)


--->A functional interface is valid even if the @FunctionalInterface annotation would be omitted. It is only for informing the compiler to enforce single abstract method inside interface.


 Note ::=
~~~~~~~
 --- use of FI :: Can be Instantiated using LE which provides Method-Impl (**********)  (--Eg:: Runnable--)
 --- use of FI :: Can be Instantiated using ME && CE also (********)
 --- java.util.function has Bunch of FI .
 --- Normal Interface if it does not have any Abstract-Methods also, Acts "-FI-" if it EXTENDS it. 
 

 Comparator in Java-8 :=
~~~~~~~~~~~~~~~~~~~~~~
 --- compare() ---> AM
      equals() ---> Still a 'FI' since this method belongs to Object-Class && can declare Other methods Belongs to    Object-Class (*******)
 --- has any Default-methods. 

 Eg :=
~~~~~~
 		System.out.println("List of employee after sorting using Lambda ..");
		Collections.sort(empList,(e1,e2)->e1.getName().compareTo(e2.getName()));
		empList.forEach(System.out::println);
		
==================

 Eg :=
~~~~
	private static void createThreadUsingLamdaExpression() {
		Runnable r=	()-> {System.out.println("My task is executing..");};
		Thread thread = new Thread(r);
		thread.start();
	}

	private static void createThreadUsingAnonymousClass() {
		Runnable r=	new Runnable() {
			@Override
			public void run() {
				System.out.println("My task is executing..");
			}
		};
		
		Thread thread = new Thread(r);
		thread.start();
	}

==================

 --- If we remove @FunctionInterface annotation then we are allowed to add another abstract method, but it will make the interface non-functional interface.

   @FunctionalInterface
   public interface MyFirstFunctionalInterface 
  {
    public void firstWork();
  }
  
 --- If we add @FunctionInterface , then Compiler Strictly Check for Only One-AM. If it found two, then throws 
 
            Invalid '@FunctionalInterface' annotation; FunctionInter is not a functional interface
   
   @FunctionalInterface
   public interface MyFirstFunctionalInterface 
  {
    public void firstWork();
	
	public void demo();  // CompileTime-Error
  }

====================

--->Conceptually, a functional interface has exactly one abstract method. Since default methods have an implementation, they are not abstract. Since default methods are not abstract you’re free to add default methods to your functional interface as many as you like.We can define any number of other methods like Default methods, Static methods.

 Eg :=
 ~~~
 @FunctionalInterface
public interface MyFirstFunctionalInterface 
{
    public void firstWork();
 
    default void doSomeMoreWork1(){
    //Method body
    }
 
    default void doSomeMoreWork2(){
    //Method body
    }
}



--->If an interface declares an abstract method overriding one of the public methods of java.lang.Object, that also does not count toward the interface’s abstract method count since any implementation of the interface will have an implementation from java.lang.Object or elsewhere. e.g. Comparator is a functional interface even though it declared two abstract methods. Why? Because one of these abstract methods “equals()” which has signature equal to public method in Object class.
e.g. Below interface is a valid functional interface.

@FunctionalInterface
public interface MyFirstFunctionalInterface 
{
    public void firstWork();
 
    @Override
    public String toString();                //Overridden from Object class
 
    @Override
    public boolean equals(Object obj);        //Overridden from Object class
}

 Eg2 :=
~~~~~~

@FunctionalInterface
public interface MyFunctionalInterface {
	
	public void functionTest();

}


public class Demo {

	public static void main(String[] args) {

		MyFunctionalInterface myFunctionalInterface = new MyFunctionalInterface() {

			public void functionTest() {
				System.out.println("FI Implemented Here !!!!!!");

			}
		};

		MyFunctionalInterface myFunctionalInterface2 = () -> System.out.println("Implementation of LM ");

	}

}



---->If we override java.lang.Object class’s method as an abstract method, which does not count as an abstract method.

---->In Java 8, java.lang.Runnable and java.util.concurrent.Callable are two very popular Functional interfaces


---> What is the difference and similarities between Function and Predicate in java 8?


 Difference :=
~~~~~~~~~~~~
1. Return Type : Function returns an Object and it is a single argument function.
Predicate return type is boolean (i.e true or false) and it is also a single argument function.


 Similarities :=
~~~~~~~~~~~~~
1. Both are functional interfaces i.e both contain single abstract method.

=========
 
 BiConsumerInterface := [ https://www.geeksforgeeks.org/java-8-biconsumer-interface-in-java-with-examples/ ]
~~~~~~~~~~~~~~~~~~~~~~~
 --- It is a part of the java.util.function package.
 --- It Represents a function which takes in two arguments and produces a result.
 --- Has One Method ::  void accept(T t, U u);
 --- Has  --andThen()-- Method which executes after above method 

 Eg :=
~~~~~~
		List<Integer> lista = new ArrayList<Integer>(); 
        lista.add(2); 
        lista.add(1); 
        lista.add(3); 
  
        // Create the second list 
        List<Integer> listb = new ArrayList<Integer>(); 
        listb.add(2); 
        listb.add(1); 
        listb.add(2); 
        
        BiConsumer<List<Integer>, List<Integer> > equals = (list1, list2) -> 
        { 
            if (list1.size() != list2.size()) { 
                System.out.println("False"); 
            } 
            else { 
                for (int i = 0; i < list1.size(); i++) 
                    if (list1.get(i) != list2.get(i)) { 
                        System.out.println("False"); 
                      //  return; 
                    } else {
                    	System.out.println(list1.get(i)+" True");
                    }
                //System.out.println("True"); 
            } 
        }; 
  
        BiConsumer<List<Integer>, List<Integer> > disp = (list1, list2) -> 
        { 
            list1.stream().forEach(a -> System.out.print(a + " ")); 
            System.out.println(); 
            list2.stream().forEach(a -> System.out.print(a + " ")); 
            System.out.println(); 
        };    
      equals.andThen(disp).accept(lista, listb); 
	  
	  

 BiFunctionInterface  := [ https://www.geeksforgeeks.org/java-bifunction-interface-methods-apply-and-addthen/ ]
~~~~~~~~~~~~~~~~~~~~~~~
 --- It is a part of the java.util.function package.
 --- It Represents a function which takes in THREE arguments and produces a result.
 --- Has One Method ::  R apply(T t, U u)
 --- Has  --andThen()-- Method which executes after above method 

 Eg :=
~~~~~
	    BiFunction<Integer, Integer, Integer> composite1 = (a, b) -> a + b; 
        composite1 = composite1.andThen(a -> 2 * a); 
        System.out.println("Composite1 = " + composite1.apply(2, 3)); 
		
		

=================/\/\\/\/\===============/\/\/\/\/\/\/\/\===========/\/\/\/\/\/\/\/\=============

======================================================================================================

METHODREFERENCE123 :=
~~~~~~~~~~~~~~~~~~~

--->Method references help to point to methods by their names. A method reference is described using :: (double colon) symbol. A method reference can be used to point the following types of methods −

 ---Static methods
 ---Instance methods
 ---Constructors using new operator (TreeSet::new)
 
  Method Reference :=
~~~~~~~~~~~~~~~~~~~
Method reference is a short-hand notation of a lambda expression to call a method. (**************) 
 
 For example: 
 
    If your lambda expression is like this ::                    str -> System.out.println(str)
    Then you can replace it with a method reference like this ::  System.out::println
		 
--> The method references can only be used to replace a single method lambda expression .


--->Method reference is represented by using double colon operator "::".  Lambda expressions are used to create method anonymously. Sometimes, the sole purpose of lambda expressions is to call existing methods.

Here is the syntax of method reference :

Object :: nameOfTheMethod

    System.out::println equivalent to System.out.println(x)

---->used for referencing a method without invoking it.it. It is used for treating methods as Lambda Expressions.

--->we can refer a method from class or object using class::methodName type syntax

  ---Class::staticMethodName    ----ClassInstance::instanceMethodName          ---Reference to constructor – Class::new

 1. SM-Reference         ----> https://github.com/kishanjavatrainer/MethodReferenceWithStaticMethod
 2.Constructor-Reference ----> https://github.com/kishanjavatrainer/ReferenceToConstructorInLambda 
 3.IM-Reference          ----> https://github.com/kishanjavatrainer/ReferenceToInstanceMethodinLambda
 
  Eg1 :=
~~~~~~
   public static void main(String[] args) {

		ExecutorService executorService = Executors.newSingleThreadExecutor();
		
		Runnable command = ClientTest::myRun;
		executorService.execute(command);
	}

	private static void myRun(){
		System.out.println("My Task is running");
	}
	

 Eg2 :=
~~~~~~
	public static void main(String[] args) {

		List<Integer> numbers = Arrays.asList(4,9,36,100);
		numbers.forEach(System.out::println);
		System.out.println("-------------------------");
		
		List<Double> findSquareRoots = ClientTest.findSquareRoots(numbers,Integer::new);
		findSquareRoots.forEach(System.out::println);
	}

	private static List<Double> findSquareRoots(List<Integer> numbers,Function<Integer, Integer> f) {
		List<Double> results = new ArrayList<>();
		numbers.forEach(x->results.add(Math.sqrt(f.apply(x)))); // Filtering-Data[SQUARE] form 'numbers' && Storing in 'results' List  (***********)
		return results;
	}
	
 
 Eg3 :=
~~~~~

	public static void main(String[] args) {

		List<Person> persons = new ArrayList<>();
		persons.add(new Person("Bean", 27));
		persons.add(new Person("Sean", 21));
		persons.add(new Person("Martin", 45));
		persons.add(new Person("Frank", 27));
		
		
	List<String> personNames =ReferenceToInstanceMethodinLambda.getPersonsName(persons,Person::getName);
	personNames.forEach(System.out::println);
	}

	private static List<String> getPersonsName(List<Person> persons, Function<Person, String> f) {
		List<String> results  = new ArrayList<>();
		persons.forEach(n->results.add(f.apply(n)));    // Filtering-Data[NAME] form 'persons' && Storing in 'results' List  (***********)
		return results;
	}
	
	
 Eg44 :=
~~~~~~~

    Class::staticMethod ///// ObjectType::instanceMethod  //// ClassName::new

   public static int compareByName(Person a, Person b) 
    { 
        return a.getName().compareTo(b.getName()); 
    } 
	
    public static int compareByName(Person a, Person b) 
    { 
        return a.getName().compareTo(b.getName()); 
    }


        // Use static method reference 
        // to sort array by age
	    Collections.sort(personList, GFG::compareByName); 
        System.out.println("Sort by name :"); 
        personList.stream().map(x -> x.getName()).forEach(System.out::println); 
 
        // Use instance method reference 
        // to sort array by name 
        ComparisonProvider comparator = new ComparisonProvider(); 
        Collections.sort(personList, comparator::compareByName); 
        System.out.println("Sort by name :"); 
        personList.stream() .map(x -> x.getName()).forEach(System.out::println);


       List<Person> personList = getObjectList(5, Person::new); 


=================/\/\\/\/\===============/\/\/\/\/\/\/\/\===========/\/\/\/\/\/\/\/\=============
======================================================================================================

DEFAULTMETHOD123 :=
~~~~~~~~~~~~~~~~

    --- default-static-method.
	--- default-instance-method.

--->It is a  non abstract method i.e have body, which can be declared inside interface.Default method is introduced in Java 8 for backward compatibility. 

--->That is if you add a new abstract method to the interface, all the implementing classes shall break. Implementing classes need to implement the added abstract method. This problem is solved by default method of java 8.


Eg:=  .....////Using super keyword along with interface name.
--
interface Vehicle {
   default void print() {
      System.out.println("I am a vehicle!");
   }
}
class Car implements Vehicle {
   public void print() {
      Vehicle.super.print();                  
   }
}

-------------------------------------
interface Vehicle {
   static void blowHorn() {
      System.out.println("Blowing horn!!!");
   }
}
class Car implements Vehicle {
   public void print() {
      Vehicle.blowHorn();                  
   }
----------------------------------------

----> "-- <(I).super.<MN> --" used to accesss default methods in Interface which Cannot use super in a static context (main-Method)
  ---This line  should be used in Instance-Method Only.(*******)

---->Us of default methods in java 8 is to enable the functionality of lambda expression in java (**********)

---->Default methods allow adding support for functional interface in core classes

---->


=================/\/\\/\/\===============/\/\/\/\/\/\/\/\===========/\/\/\/\/\/\/\/\=============
======================================================================================================

STREAMS123 :=   
~~~~~~~~~~~    [ https://www.concretepage.com/java/java-8/ ]

 --- Instead, a stream carries values from a source through a pipeline. (**********)
 --- It is not a data structure that stores elements. 
		   
--->It is defined as a sequence of elements from a source that supports aggregate operations on them. (Eg :: Youtube)  

--->A Stream in Java can be defined as a sequence of elements from a source that supports aggregate operations on them. 

--->Java 8 Streams are designed in such a way that most of the stream operations returns streams only. This help us creating chain of the stream operations. This is called as pipe-lining.

--->Stream is a conceptually fixed data structure, in which elements are computed on demand
  --- This gives rise to significant programming benefits. The idea is that a user will extract only the values they require from a Stream, and these elements are only produced—invisibly to the user—as and when required. This is a form of a producer-consumer relationship.
  
  
  Stream API :=
~~~~~~~~~~~~~~~
 --- It is used to process collections of objects. 
 --- A stream is a sequence of objects that supports various methods which can be pipelined to produce the desired result. 
 --- Streams don't change the original data structure, they only provide the result as per the pipelined methods.
  
  
 Difference between Streams && Collections :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 --- Elements are Computed on Demand-Basis , which is not possible using '-COLLECTIONS-'.
 --- Elements can accessed using Index && Iteration is done Internally ,  which is not possible using '-COLLECTIONS-'. 
 
 
Stream, they will be as follows :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ---Not a data structure
 ---Designed for lambdas
 ---Do not support indexed access
 ---Can easily be outputted as arrays or lists
 ---Lazy access supported
 ---Parallelizable
 
 
 Advantages :=
~~~~~~~~~~~~~
 --- Reduce Lot of Code && Perform Bulk Operation 
 --- Manipulate && Filter Data in List 


Examples ::=
~~~~~~~~~
---> ll.stream() :: Stream<Integer>();  //// collect(Collectors.toList());
	  ll.filter() :: List<Integer>()  [OR]  Integer[]
	  
----> map.entrySet().stream() (**************************)

---> Stream<Integer> stream = Stream.of(1,2,3,4,5,6,7,8,9);
      stream.forEach(p -> System.out.println(p));
	  
 GIT :=
~~~~~~
   https://github.com/Java-Techie-jt/java8
   https://github.com/java8/Java8InAction/tree/master/src/main/java/lambdasinaction
 
 

==========================		 

Methods := [ Youtube ---> Play Java ********]
~~~~~~~    [ https://howtodoinjava.com/java8/java-streams-by-examples/ ]
           
		   [ https://github.com/amigoscode/java-streams-youtube/blob/master/src/main/java/Main.java ] (******)
		   [ https://github.com/joeyajames/Java/blob/master/Java%208%20Streams/JavaStreams.java ]     (*******)
 
           [ https://github.com/RameshMF/java-8-tutorial/tree/master/src/com/ramesh/java8 ]
           [ https://github.com/winterbe/java8-tutorial/tree/master/src/com/winterbe/java8/samples/stream ]
  
  
Intermediate-Operations :=  /// Returns Streams && Lazily Loaded. 
~~~~~~~~~~~~~~~~~~~~~~~~

    ------ filter('1'-COND):List<T>.......map('1'):List<T>.......flatMap():List<T>.......distinct()List<T> -----
  
    ------ sorted().......peek().........limit(20).......skip(10)----------- 


Terminal-Operations :=
~~~~~~~~~~~~~~~~~~~~~

         ----toArray():[].......collect():List<T>....... reduce():Optional<T> ----------- 

          ------min(COMP):Optional<T>.......max(COMP):Optional<T>.......count():Long ----------
	   
      ------forEach():<T>.......findFirst():String.......findAny().....forEachOrdered()---------

      ------anyMatch('1'-COND):boolean.......allMatch('1'-COND):boolean.......noneMatch('1'-COND):boolean ------------
	  
	  
 Main differences between Intermediate and Terminal Stream operations are as follows :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 I. Evaluation: Intermediate operations are not evaluated until we chain it with a Terminal Operation of Stream. 
                Terminal Operations can be independently evaluated.

 II. Output: The output of Intermediate Operations is another Stream. (**********)
             The output of Terminal Operations is not a Stream.

 III. Lazy: Intermediate Operations are evaluated in lazy manner.  (**********)
            Terminal Operations are evaluated in eager manner.

 IV. Chaining: We can chain multiple Intermediate Operations in a Stream. 
               Terminal Operations cannot be chained multiple times.

 V. Multiple: There can be multiple Intermediate operations in a Stream operation. 
              There can be only one Terminal operation in Stream processing statement

=====================================================
 
 map -------->  map(x -> x * x)  //// String::toLowerCase /// converts Stream<X> to Stream<Y>  && returns a new Stream (******)
 
 
                     Data Transformation ---->  Converting List<Employee> to List<firstName> 
 
 flatmap ---->  https://howtodoinjava.com/java8/stream-flatmap-example/             ////  One-To-Many Mapping
                flatten a Stream of collections to a stream of objects             //// List<List<Integer>> (*****)
                flattening is referred to as merging multiple collections/arrays into one. (********)
                flatMap(x -> x.stream())  ///// flatMap(x -> Arrays.stream(x))


                       Flattering ----> Convert Stream(Stream)  to Single-Stream 

 flatMap :=
~~~~~~~~

		
		  String[][] array2 = new String[][]{{"a", "b"}, {"c", "d"}, {"e", "f"}};

		  List<String> collect = Stream.of(array2)     // Stream<String[]>
		          .flatMap(Stream::of)                // Stream<String>
		          .filter(x -> !"a".equals(x))        // filter out the a
		          .collect(Collectors.toList());      // return a List

		  collect.forEach(System.out::println);
		  
		  
		// get Total Number of male and female employees Average Age
				Map<String, Double> collect = list.stream().collect(Collectors.groupingBy(Employee::getEmpGender, Collectors.averagingInt(Employee::getEmpAge)));
				
				

 ‘GROUP BY' :=  [ https://mkyong.com/java8/java-8-collectors-groupingby-and-mapping-example/ ]
~~~~~~~~~~~~
 ---- functionality similar to the  clause in the SQL language. 
 ---- We use them for grouping objects by some property and storing results in a Map instance.

   List<String> items =
	                Arrays.asList("apple", "apple", "banana",
	                        "apple", "orange", "banana", "papaya");

	        Map<String, Long> result =
	                items.stream().collect(
	                        Collectors.groupingBy(
	                                Function.identity(), Collectors.counting()
	                        )
	                );

	        System.out.println(result);

			
===========================================================================

 distinct ----> Takes Only Unique elements. 	


 peek --------> Returns a new Stream consist of elements from the original Stream. 
                list.stream().peek(System.out::println).collect(Collectors.toList());    


================			
			
 sorted ------> sorted() //// sorted(Comparator.comparing(Person::getAge).thenComparing(Person::getGender).reversed())
                sorted(Comparator.reverseOrder())
				return i2.compareTo(i1); //// Reverse-Comparator (******)
				
				

 max && min ----> max(Comparator.comparing(Person::getAge)); //// min(Comparator.comparing(Person::getAge));
                  max() method throws NullPointerException if the maximum element found is null (*******)
				  max(maxComparator); //// System.out.println(maxNumber.get());

 reduce ---------> reduce((s1,s2) -> s1 + "#" + s2);
 
 forEachOrdered ----> Orders the elements. 

=======================================================

 MAP :=
~~~~~~
 --- map() is used to transform one object into other by applying a function 
 
 --- Stream.map() function to convert a stream of strings to stream of integers. Here the function Integer::valueOf() takes one string from stream at a time, and convert the string to integer and put in another stream of integers, which is then collected using Collectors.toList().

--->flatMap() operation has the effect of applying a one-to-many transformation to the elements of the stream, and then flattening the resulting elements into a new stream.
 ----The function used for transformation in flatMap() is a stateless function and returns only a stream of new values.

---->Stream.skip() method can be a useful in certain cases where we need to get the elements from a stream but first we need to skip few elements from the stream. 


 Sorted() in Reverse Order :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   List<Employee> listOfEmployee = empList.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());
   
   
 GeyKeys using Java-8 :=
~~~~~~~~~~~~~~~~~~~~~~~~
   Map>Integer , Integer> Imap =  map.entrySet().stream().filter(map1-> map1.getKey() >5)
                                            .collect(Collectors.toMap(map1 -> map1.getKey(), map1 -> map1.getValue()));

=====================================================

  
 ‘GROUP BY' :=
~~~~~~~~~~~~
 ---- functionality similar to the  clause in the SQL language. 
 ---- We use them for grouping objects by some property and storing results in a Map instance.


   List<String> items =
	                Arrays.asList("apple", "apple", "banana",
	                        "apple", "orange", "banana", "papaya");

	        Map<String, Long> result =
	                items.stream().collect(
	                        Collectors.groupingBy(
	                                Function.identity(), Collectors.counting()
	                        )
	                );

	        System.out.println(result);
			
=====================================================			

 Arrays Using Streams := (************)
~~~~~~~~~~~~~~~~~~~~~~~~
		String[] arr = { "Geeks", "for", "Geeks" }; 
        // Using Arrays.stream() to convert 
        // array into Stream 
        Stream<String> stream = Arrays.stream(arr); 
  
        // Displaying elements in Stream 
        stream.forEach(str -> System.out.print(str + " ")); 
		
		
		
		      int arr[] = { 1, 2, 3, 4, 5 }; 
  
        // Using Arrays.stream() to convert 
        // array into Stream 
        IntStream stream = Arrays.stream(arr, 1, 3); 
  
        // Displaying elements in Stream 
        stream.forEach(str -> System.out.print(str + " "));


 Eg to Remove duplicate form Array :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Set<Integer> uniqueElements    = new HashSet<>();      
    Set<Integer> duplicateElements =  Arrays.stream(inputArray)
                                            .filter(i -> !uniqueElements.add(i))
                                            .boxed()
                                            .collect(Collectors.toSet());

==========================================================================================

 Java88 :=    [ https://stackify.com/streams-guide-java-8/]
~~~~~~~~~
  	static {
		list = Arrays.asList(new Employee("1", "ram", 22000, 22, "Male", "B"),
				new Employee("1", "rama", 22004, 22, "Male", "A"), new Employee("2", "krishna", 61525, 28, "Male", "A"),
				new Employee("2", "krish", 109787, 28, "Male", "A"),
				new Employee("3", "seeta", 33990, 29, "Female", "B"),
				new Employee("1", "radha", 44456, 32, "Female", "A"),
				new Employee("1", "ramya", 50598, 22, "Female", "A"),
				new Employee("1", "shyam", 12229, 37, "Male", "A"), new Employee("1", "kiran", 74383, 44, "Male", "B"),
				new Employee("1", "geeta", 179845, 50, "Female", "B"));
	}
	
	
	public class Employee {
	private String empId;
	private String empName;
	private int empSal;
	private int empAge;
	private String empGender;
	private String deptName;
	 }
	 
-------------------------------------------------------------------------------------------------------
	 
 --- min() and max() return the minimum and maximum element in the stream respectively, based on a comparator.
 
 --- Stream is a stream of object references. However, there are also the IntStream, LongStream, and DoubleStream, which are primitive specializations for int, long and double respectively.
 
 --- These specialized streams do not extend Stream 
 
 ---  The parallel sort uses Fork/Join Framework for sorting sub arrays parallelly.
 
 
 
-------------------------------------------------------------------------------------------------------------------
	
		  String[][] array2 = new String[][]{{"a", "b"}, {"c", "d"}, {"e", "f"}};

		  List<String> collect = Stream.of(array2)     // Stream<String[]>
		          .flatMap(Stream::of)                // Stream<String>
		          .filter(x -> !"a".equals(x))        // filter out the a
		          .collect(Collectors.toList());      // return a List

		  collect.forEach(System.out::println);
		  
-----------------------------------------------------------		 
 
	 Set<String> collect =
                list.stream()
                        .map(x -> x.getBook())                              //  Stream<Set<String>>
                        .flatMap(x -> x.stream())                           //  Stream<String>
                        .filter(x -> !x.toLowerCase().contains("python"))   //  filter python book
                        .collect(Collectors.toSet());                       //  remove duplicated

        collect.forEach(System.out::println);
	
-----------------------------------------------------------

      return list.stream()
            .filter(n -> n % 2 == 1)
            .max(Integer::compare)
            .orElse(0);

-----------------------------------------------------------

     List<String> names = studentlist.stream() .map(n->n.name).collect(Collectors.toList());
								   
-----------------------------------------------------------	


  // x is a String[]
  List<String[]> result = stream1
          .filter(x -> {
              for(String s : x){      // really?
                  if(s.equals("a")){
                      return false;
                  }
              }
              return true;
          }).collect(Collectors.toList());

--------------------------------------------------------------------------		  

  String[][] array = new String[][]{{"a", "b"}, {"c", "d"}, {"e", "f"}};

  List<String> collect = Stream.of(array)     // Stream<String[]>
          .flatMap(Stream::of)                // Stream<String>
          .filter(x -> !"a".equals(x))        // filter out the a
          .collect(Collectors.toList());      // return a List
		  
		  
		          Set<String> collect =
                list.stream()
                        .map(x -> x.getBook())                              //  Stream<Set<String>>
                        .flatMap(x -> x.stream())                           //  Stream<String>
                        .filter(x -> !x.toLowerCase().contains("python"))   //  filter python book
                        .collect(Collectors.toSet());  


   Set<String> collect2 = list.stream()
                    //.map(x -> x.getBook())
                    .flatMap(x -> x.getBook().stream())                 //  Stream<String>
                    .filter(x -> !x.toLowerCase().contains("python"))   //  filter python book
                    .collect(Collectors.toSet());
					
	memberNames.stream().filter((s) -> s.startsWith("A"))
                    .map(String::toUpperCase)
                    .forEach(System.out::println);
------------------------------------------------------------------------------------------

					// get Total Number of male and female employees
		Map<String, Long> collect = list.stream()
				.collect(Collectors.groupingBy(Employee::getEmpGender, Collectors.counting()));
		System.out.println(collect);
		System.out.println("=============================================");


		// get Total Number of Each male and female employees Average Age
		Map<String, Long> collect6 = list.stream()
				.collect(Collectors.groupingBy(Employee::getEmpGender, Collectors.counting()));
		System.out.println(collect6);
		System.out.println("=============================================");


		// get Total Average Salary of Each male and female employees Average Age
		Map<String, Double> collect2 = list.stream().collect(
				Collectors.groupingBy(Employee::getEmpGender, Collectors.averagingDouble(Employee::getEmpSal)));
		Set<Entry<String, Double>> entrySet = collect2.entrySet();
		for (Entry<String, Double> ent : entrySet) {
			System.out.println(ent.getKey() + "  " + ent.getValue());
		}
		System.out.println("=============================================");


		// Max Salary of employee
		Optional<Employee> collect3 = list.stream()
				.collect(Collectors.maxBy(Comparator.comparing(Employee::getEmpSal)));
		System.out.println(collect3);
		System.out.println("=============================================");


		// get all employees name in Organization
		List<String> collect4 = list.stream().map(Employee::getEmpName).collect(Collectors.toList());
		System.out.println(collect4);
		System.out.println("=============================================");


		// Count Number of Employees in Each Department
		Map<String, Long> collect5 = list.stream()
				.collect(Collectors.groupingBy(Employee::getDeptName, Collectors.counting()));
		System.out.println(collect5);
		System.out.println("=============================================");


		// Details of Youngest Male employee who works in 'A' Department
		Optional<Employee> min = list.stream().filter(emp -> emp.getEmpGender() == "Male" && emp.getDeptName() == "A")
				.min(Comparator.comparingInt(Employee::getEmpAge));
		System.out.println(min);
		System.out.println("=============================================");


		// Maximum salary of employee
		Optional<Employee> findFirst = list.stream().sorted(Comparator.comparingInt(Employee::getEmpSal)).findFirst();
		System.out.println(findFirst);
		System.out.println("=============================================");


		// Display Male && Female Employee in 'A' Department
	 Map<String, Long> collect7 = list.stream().filter(emp -> emp.getDeptName() == "B")
				.collect(Collectors.groupingBy(Employee::getEmpGender, Collectors.counting()));
	 System.out.println(collect7);
		System.out.println("=============================================");
		
		
		// Average salary  Male && Female Employee in all Departments
	  Map<String, Double> collect8 = list.stream().collect(Collectors.groupingBy(Employee::getEmpGender, Collectors.averagingDouble(Employee::getEmpSal)));
	 System.out.println(collect8);
		System.out.println("=============================================");

          // List<Employee> to Employee[] emp
           Employee[] employees = list.stream().toArray(Employee[]::new);
		   
		   
          // Count Employees who are having salary greater than 20000
		Long empCount = list.stream().filter(e -> e.getEmpSal() > 20000).count();
		System.out.println("=============================================");
		
		
		 // Comparator for Objects 
		 List<Employee> employees = empList.stream().sorted((e1, e2) -> e1.getName().compareTo(e2.getName())).collect(Collectors.toList());
		System.out.println("=============================================");
		
		
		// Min of Diff of Emp_Id's 
		  Employee firstEmp = list.stream().min((e1, e2) -> e1.getId() - e2.getId()).orElseThrow(NoSuchElementException::new);	  
		  Employee maxSalEmp = empList.stream().max(Comparator.comparing(Employee::getSalary)).orElseThrow(NoSuchElementException::new);
		  
		  
		   // Collectors.joining() will insert the delimiter between the two String elements
		     String empNames = empList.stream().map(Employee::getName).collect(Collectors.joining(", ")).toString();

-----------------------------------------------------------

		
		// Used in Junit Test -Case , fetches Objects && storing in List by ID 
		 List<Employee> employees = Stream.of(empIds).map(employeeRepository::findById).collect(Collectors.toList());
		 
		 
		// Used in Junit Test -Case , fetches Objects by applying Validation && storing in List by ID 
	   List<Employee> employees = Stream.of(empIds).map(employeeRepository::findById)
      .filter(e -> e != null)
      .filter(e -> e.getSalary() > 200000)
      .collect(Collectors.toList());
	  
	  
	  
 toCollection() :=
~~~~~~~~~~~~~~
 --- We can use Collectors.toCollection() to extract the elements into any other collection by passing in a Supplier<Collection>. 
 --- We can also use a constructor reference for the Supplier:	  
 
 @Test
  public void whenToVectorCollection_thenGetVector() {
    Vector<String> empNames = empList.stream()
            .map(Employee::getName)
            .collect(Collectors.toCollection(Vector::new));
    
    assertEquals(empNames.size(), 3);
  }
		 

 partitioningBy :=
~~~~~~~~~~~~~~~~~
 ---  partition a stream into two – based on whether the elements satisfy certain criteria or not.
 
 
 Map<Boolean, List<Employee>> collect10 = list.stream()
				.collect(Collectors.partitioningBy(i -> i.getEmpSal() % 2 == 0));

		Set<Entry<Boolean, List<Employee>>> entrySet3 = collect10.entrySet();

		for (Entry<Boolean, List<Employee>> et : entrySet3) {

			System.out.println("-------------" + et.getKey() + "------------------");

			List<Employee> value = et.getValue();

			for (Employee emp : value) {
				System.out.println(emp);
			}

		}

===============================================================================================

---->Stream.forEach(Consumer action) method to traverse all the elements of stream and performs an action for each element of this stream.

 Eg11 :=
~~~~~~
   List<Integer> list = Arrays.asList(2, 4, 6, 8, 10); 
   list.stream().sorted(Comparator.reverseOrder()).forEach(System.out::println);

---->Stream.forEachOrdered(Consumer action) method to traverse all the elements and performs an action for each element of this stream

---->The behavior of forEach() operation is explicitly non-deterministic. ( No Guaranty of Ordering-elements )
    The behavior of forEachOrdered() operation respects the the encounter order of the stream if the stream has a defined encounter order whether it is parallel stream or sequential.
	
 Eg2 :=
 ~~~~~
        List<Integer> list = Arrays.asList(2, 4, 6, 8, 10);
        list.stream().parallel().forEach( System.out::println );         // 6,10,8,4,2
        list.stream().parallel().forEachOrdered( System.out::println );  //2,4,,6,8,10
		list.stream().sorted(Comparator.reverseOrder()).forEachOrdered(System.out::println);  // 10,8,6,4,2


---->Stream.toArray() to convert stream to array


 Eg3:=
~~~~~~
        Stream<String> tokenStream = Arrays.asList("A", "B", "C", "D").stream();  //stream
        String[] tokenArray = tokenStream.toArray(String[]::new);   //array
        System.out.println(Arrays.toString(tokenArray));


 Eg4 :=
~~~~~~~
        Employee[] employeesArray = employeeList.stream().filter(e -> e.getSalary() < 400).toArray(Employee[]::new);		


 Eg5 :=
~~~~~~
  stream().min(Comparator.comparing(StageMasterEntity::getOrderNo)).orElseThrow(NoSuchElementException::new);
          return stageMasterEntity.getStageId();
		
		
 Eg for Collect() :=   // ****Collectors()*******
~~~~~~~~~~~~~~~~~~~~ 
    //  List<Product> ListOfPersons = productList.stream().collect(Collectors.toList());
	//  List<Product> ListOfPersons = productList.stream().map(Employee::getName()).collect(Collectors.toList());
	//  String str  = productList.stream().map(Employee::getName()).collect(Collectors.joining(",","[","]"));
	
	//  Double str  = productList.stream().collect(Collectors.averagingInt(Employee::getAge());
	
		LinkedList<Product> linkedListOfPersons = productList.stream().collect(toLinkedList);
		linkedListOfPersons.forEach(System.out::println);
		
		              https://github.com/kishanjavatrainer/StreamReductionDemo

		
---->Stream min() method returns an Optional describing the smallest element of this stream, or an empty Optional if the stream is empty.
   ----It may throw NullPointerException if the smallest element is null.
   
 Eg :=         Optional<Integer> minNumber = list.stream().min((i, j) -> i.compareTo(j));
 ~~~~

---->Stream.max() method to select the largest element in the stream according to the comparator provided in its argument.

Eg:=
~~
  List<Integer> list = Arrays.asList(2, 4, 1, 3, 7, 5, 9, 6, 8);
         
        Comparator<Integer> maxComparator = new Comparator<Integer>() {
             
            @Override
            public int compare(Integer n1, Integer n2) {
                return n1.compareTo(n2);
            }
        };
 
        Optional<Integer> maxNumber = list.stream()
                                .max(maxComparator);
 
        System.out.println(maxNumber.get());

---->count the number of elements in stream in Java 8, use either the Stream.count() or Collectors.counting() methods.

 Eg:=
~~~~
     long count = Stream.of("how","to","do","in","java").count();
    System.out.printf("There are %d elements in the stream %n", count);
	
	
	
---->Stream.anyMatch (Predicate predicate) is terminal-short-circuiting operation which is used to check if the stream contains any matching element with provided predicate.

 Eg1:=
~~~~
		 Stream<String> stream = Stream.of("one", "two", "three", "four");
		 boolean match = stream.anyMatch(s -> s.contains("four"));
		   
		 Stream<String> stream = Stream.of("one", "two", "three", "four");
         boolean match = stream.allMatch(s -> s.contains("\\d+") == false );
		 
		 Stream<String> stream = Stream.of("one", "two", "three", "four");
		 boolean match = stream.noneMatch( s -> s.contains("\\d+") );

--->you want to particular job using multiple threads in parallel cores, all you have to call method parallelStream() method instead of stream() method.

--->Stream interface has three more similar methods which produce IntStream, LongStream and DoubleStream respectively after the map operation


 distinct() :=
~~~~~~~~~~~~
		List<String> list = new ArrayList<>();
		list.add("Sean");
		list.add("Martin");
		list.add("Frank");
		list.add("Andrew");
		
		Stream<String> stream = list.stream();
		long count = list.stream().distinct().count();
		System.out.println(count);
		
		Terminal-Operations ----> (Matches) Returns Boolean 
		
		Intermediate-Operations ----> Stream 
		
		 Eg (Match) :=
~~~~~~~~~~~~
  		Stream<Student> filteredList = list.stream().filter(s->s.getAge()>25);
		filteredList.forEach(System.out::println);
		
		System.out.println("-------------------");
		
		boolean allMatch = list.stream().allMatch(s->s.getName().contains("K"));
		System.out.println(allMatch);
		
		System.out.println("-------------------");
		boolean anyMatch = list.stream().anyMatch(s->s.getAge()>35);
		System.out.println(anyMatch);
		System.out.println("-------------------");
		boolean noneMatch = list.stream().noneMatch(s->s.getAge()>55);
		System.out.println(noneMatch); 
		
		
 Map ----> Apply Special function to Stream && Collect into another Stream 
 
      https://github.com/kishanjavatrainer/MappingStreamAPITest

 Infinite Streams :=
~~~~~~~~~~~~~~~~~~~

   limit()........
		
		Stream<Integer> iterate = Stream.iterate(0, i->i+2);
		List<Integer> collect = iterate.limit(10).collect(Collectors.toList());
		collect.forEach(System.out::println);


--->

--->

=================/\/\\/\/\===============/\/\/\/\/\/\/\/\===========/\/\/\/\/\/\/\/\=============
======================================================================================================

OPTIONAL123 := 
~~~~~~~~~~~~
  
  (.....ofNullable(), isPresent(), isEmpty(), ofNullable(),  orElseThrow(), of(),  get()......)  (******)

---->Optional is a final Class introduced as part of Java SE 8. It is defined in java.util package.

---->It provides methods which are used to check the presence of a value for the particular variable. (***********)

----> Optional<T> acts like a container for type T. 
      If it's value inside container is not null. It will return Value-Of-Object.
	  If it's value inside container is null, It allows doing some predefined-Actions returns Empty Optional i.e
	  and Not throws NullPointerException.

---->It is a bounded collection that is it contains at most one element only. It is an alternative to “null” value.

Main Advantage of Optional is:

It is used to avoid null checks.
It is used to avoid “NullPointerException”.

---->always initialize your object references with some value, and never with null. 

---->Optional is a way of replacing a nullable T reference with a non-null value. An Optional may either
 contain a "--non-null--" T reference (in which case we say the reference is “present”), or it may 
 contain "--nothing--" (in which case we say the reference is “absent”).
 
 Eg:=
~~~~
        Optional<Integer> canBeEmpty1 = Optional.of(5);
        canBeEmpty1.isPresent();                    // returns true
        canBeEmpty1.get();                          // returns 5
 
        Optional<Integer> canBeEmpty2 = Optional.empty();
        canBeEmpty2.isPresent();                    // returns false
		
		
----> to retrieve a record by id or some fields from the database, basically, we are not sure whether the record exists or not, in that case, the method returns the null reference.Code to avoid such null pointer exception

===============================================================================================================

 StringJoiner890 := [https://www.javaguides.net/2018/07/java-8-stringjoiner-class.html]
~~~~~~~~~~~~~~~~~    https://www.javatpoint.com/java-stringjoiner
   
 
 ----> used to construct a sequence of characters separated by a delimiter  (,) / (-). 
 
 
 
 Collections singletonList()  :=   [ https://www.geeksforgeeks.org/collections-singletonlist-method-in-java-with-examples/ ]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ----> Return an immutable list containing only the specified object. 
 ---> The returned list is serializable. This list will always contain only one element thus the name singleton list.
 ----> When we try to add/remove an element on the returned singleton list, it would give UnsupportedOperationException.
 
 
 
 CompletableFuture (C) :=    ////  belongs to java.util.cocurrent package. //////  Java-8
~~~~~~~~~~~~~~~~~~~~~~~~
 --- Asynchronous programming. Asynchronous programming means writing non-blocking code. 
 --- It runs a task on a separate thread than the main application thread and notifies the main thread about its progress, completion or failure.
 
 

=================/\/\\/\/\===============/\/\/\/\/\/\/\/\===========/\/\/\/\/\/\/\/\=============
======================================================================================================


 ForEach990 := present in Iterable (I) && Accepts Consumer(FI) 
~~~~~~~~~~~~~
 --- Internally it uses the enhanced for-loop.
 --- While using parallel streams, use forEachOrdered() if order of the elements matter during the iteration.
 	
  Eg11 :=
~~~~~~~~
    	Map<Integer,Employee> map = new HashMap<>();
		map.put(19022, new Employee("Sean", "sean.m@gmail.com", 90000.00));
		map.put(19044, new Employee("Andrew", "andy.cs@gmail.com", 70000.00));
		map.put(19055, new Employee("Martin", "martin.m300@gmail.com", 80000.00));
		
		Set<Entry<Integer, Employee>> entrySet = map.entrySet();
		for (Entry<Integer, Employee> entry : entrySet) {
			System.out.println(entry.getKey());
			System.out.println(entry.getValue());
		}
		
		System.out.println("----------------------------------------");
		
		Set<Integer> keySet = map.keySet();
		for (Integer key : keySet) {
			System.out.println(key);
			System.out.println(map.get(key));
		}
		
		System.out.println("----------------------------------------");	
		map.forEach((k,v)->System.out.println(k+"\t"+v));
		
 
 Eg22 :=
~~~~~~
		empList.add(new Employee("Raj", 90000.00, "HR"));
		empList.add(new Employee("Frank", 80000.00, "Finance"));
		empList.add(new Employee("Kishan", 30000.00, "HR"));
		empList.add(new Employee("Sean", 90000.00, "Finance"));
		empList.add(new Employee("Rajesh", 90000.00, "HR"));
		
		empList.forEach(s->System.out.println(s));
		System.out.println("------------------------------------------------");
		
		empList.removeIf(s->"HR".equalsIgnoreCase(s.getDeptName()));	

  		System.out.println("-------------------------------");
		System.out.println("Employee sorted by salary..");
		
		empList.sort((e1,e2)->e1.getSalary()>e2.getSalary()?1:-1);
		empList.forEach(System.out::println);
		
		System.out.println("-------------------------------");
		
		empList.replaceAll(e->{
			if(e.getSalary()>60000.00){
				return e;
			}else{
				e.setSalary(e.getSalary()+e.getSalary()*0.1);
				return e;
			}
		});
		empList.forEach(System.out::println);


=================/\/\\/\/\===============/\/\/\/\/\/\/\/\===========/\/\/\/\/\/\/\/\=============
======================================================================================================

 ComparatorInJava :=
~~~~~~~~~~~~~~~~~~~

 Eg11 :=
~~~~~~~~
   Comparator<Employee> comp = ( o1,   o2)-> o1.getEmpName().compareTo(o2.getEmpName());
		
		Collections.sort(listEmployees,comp);
		 listEmployees.forEach(System.out::println);
			
		 System.out.println("-----------------------------------");
		

			Collections.sort(listEmployees,new AgeComparator());
			 listEmployees.forEach(System.out::println);
	
	
  Collections.sort(empList, (emp1, emp2) -> comp.compare(emp1, emp2));
	
	
 Eg22 :=
~~~~~~~~			 
  Comparator<Employee> compareById_1 = Comparator.comparing(e -> e.getId());
  
  Comparator<Employee> compareById_2 = (Employee o1, Employee o2) -> o1.getId().compareTo( o2.getId() );


 Eg33 :=
~~~~~~~
  Comparator<Employee> comparator = Comparator.comparing(e -> e.getFirstName());
    employees.sort(comparator.reversed());

  employees.sort(Comparator.comparing(e -> e.getFirstName()));

    //Sort all employees by first name
    employees.sort(Comparator.comparing(e -> e.getFirstName()));
     
    //OR you can use below
    employees.sort(Comparator.comparing(Employee::getFirstName));


 Eg44 :=
~~~~~~
StageMasterEntity stageMasterEntity = stageMasterEntities.stream().min(Comparator.comparing(StageMasterEntity::getOrderNo)).orElseThrow(NoSuchElementException::new);


 Strings :=
~~~~~~~~~~
List<String> sorted = strings
        .stream()
        .sorted((s1, s2) -> s1.compareTo(s2))
        .collect(Collectors.toList());

=================/\/\\/\/\===============/\/\/\/\/\/\/\/\===========/\/\/\/\/\/\/\/\=============
======================================================================================================

 OthersFeatureINJava :=
~~~~~~~~~~~~~~~~~~~~~~

 DATE := java.time.*
~~~~~~~

 https://github.com/kishanjavatrainer/Java8DateTimeDemo

   LocalDate /// LocalTime //// LocalDateTime

================================

 String in Java-8 := [ https://github.com/kishanjavatrainer/StringJoinerDemo ]
~~~~~~~~~~~~~~~~~~~
 --- join() //// Works with ArrayList

 Eg :=
-----
       String joinedStr = String.join("-", "Hello","India",null);
		System.out.println(joinedStr);
		
		List<String> names = new ArrayList<>();
		names.add("KK");
		names.add("PK");
		names.add("SK");
		names.add("MK");
		names.add("KK");
		String joinedString = String.join(",", names);
		System.out.println(joinedString);
		
 
 StringJoiner in Java-8 :=
~~~~~~~~~~~~~~~~~~~~~~~~~
		StringJoiner joiner = new StringJoiner(",");
		joiner.add("How").add("are").add("you?");
		
		System.out.println(joiner);
		
		StringJoiner joiner2 = new StringJoiner(" ", "[", "]");
		joiner2.add("India").add("is").add("beautiful").add("country!!!");
		
		System.out.println(joiner2);
		
		StringJoiner mergedStr = joiner.merge(joiner2);
		System.out.println(mergedStr);
		
================================
 
 IO in Java-8 :=
~~~~~~~~~~~~~~~
 

================================

 Optional := [ https://github.com/kishanjavatrainer/Java8OptionalDemo ]
~~~~~~~~~~~~
 --- returns Empty Optional. 
 

 
  Base64 :=  [ https://github.com/kishanjavatrainer/Java8Base64EncodeAndDecodeDemo ]  Simple /// Url /// MIME 
 ~~~~~~~~~
 --- Encode / Decode Text
 --- *****Base64DOT****


 Nashron := [ https://github.com/kishanjavatrainer/NashornJava8Demo ]
~~~~~~~~~~
 --- Improved JS-Engine && Gives Better Performance than Rhino .
 --- It Directly Compiles Code  && Passes to JVM.
 
 
    Bi-Consumer ----> https://github.com/kishanjavatrainer?tab=repositories&q=biconsumer&type=&language=
	Bi-Function ----> https://github.com/kishanjavatrainer?tab=repositories&q=bifunction&type=&language=
	
  String_Joiner ----> https://github.com/kishanjavatrainer/StringJoinerDemo
	
 
  Lambda-Expression (Best_Practises) ---->       https://github.com/kishanjavatrainer?tab=repositories&q=LambdaExpression&type=&language= 
   
                        1111 ---> Method Takes String and Returns 


 Unsigned ----> POSITIVE

================================ 
 
 Wrapper Classes in Java--8 :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		String unsignedString = Integer.toUnsignedString(10, 2);
		System.out.println(unsignedString);
		String unsignedString2 = Integer.toUnsignedString(10);
		System.out.println(unsignedString2);
		
		int parseUnsignedInt = Integer.parseUnsignedInt("1010", 2);
		System.out.println(parseUnsignedInt);
		
		int divideUnsigned = Integer.divideUnsigned(100, 25);
		System.out.println(divideUnsigned);
		int remainderUnsigned = Integer.remainderUnsigned(100, 24);
		System.out.println(remainderUnsigned);
		
		int sum = Integer.sum(100, 20);
		System.out.println(sum);
		
================================
	

=================/\/\\/\/\===============/\/\/\/\/\/\/\/\===========/\/\/\/\/\/\/\/\=============
======================================================================================================

 TYPEINTERFERENCE123 :=
~~~~~~~~~~~~~~~~~~~~

---->Type Inference means determining the Type by compiler at compile-time.It is not new feature in Java SE 8. It is available in Java 7 and before Java 7 too.


==================================================================================================================

Explain Differences between Collection API and Stream API?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
1.	It’s available since Java 1.
2	It is introduced in Java SE8

2.	It is used to store Data(A set of Objects).	
It is used to compute(Count) data(Computation on a set of Objects).

3.	Collection Object is constructed Eagerly.
Stream Object is constructed Lazily.

4.	We can use both Spliterator and Iterator to iterate elements. 
We can use forEach to performs an action for each element of this stream.	 

5.	Typically, it uses External Iteration concept to iterate Elements such as Iterator.	
Stream API uses internal iteration to iterate Elements, using forEach methods.

7.	We add elements to Collection object only after it is computed completely.	
We can add elements to Stream Object without any prior computation. That means Stream objects are computed on-demand.

8.	We can iterate and consume elements from a Collection Object at any number of times.	
We can iterate and consume elements from a Stream Object only once.




What is Spliterator in Java SE 8?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Spliterator stands for Splitable Iterator. It is newly introduced by Oracle Corporation as part Java SE 8.
Like Iterator and ListIterator, It is also one of the Iterator interface.


---->Differences between Spliterator and Iterator  in Java SE 8? 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.	It is introduced in Java SE 8.	
It is available since Java 1.2.

2. Splitable Iterator	
  Non-Splitable Iterator
  
3.	It is used in Stream API.	
 It is used for Collection API.
 
4. It uses Internal Iteration concept to iterate Streams.	
   It uses External Iteration concept to iterate Collections.
   
5. We can use Spliterator to iterate Streams in Parallel and Sequential order.
 We can use Iterator to iterate Collections only in Sequential order.
	
6.We can get Spliterator by calling spliterator() method on Stream Object.	
  We can get Iterator by calling iterator() method on Collection Object.
  
7.Important Method: tryAdvance()	
  Important Methods: next(), hasNext()


 External-Iterator := 
~~~~~~~~~~~~~~~~~~~~~
 ---control over the iteration of elements lies with the iterator itself. 
 ---programmer only declares what is to be done and does not manage and control how the iteration of individual elements take place
 
   Eg :=  items.forEach(item -> System.out.println(item));
  ~~~~

======================================

Predicate335 :=
~~~~~~~~~~~~
---->Predicate is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference

---->use predicates anywhere where you need to evaluate a condition on group/collection of similar objects such that evaluation can result either in true or false.

Eg :=
~~~~~
    public static Predicate<Employee> isAdultFemale() {
     return p -> p.getAge() > 18 && p.getGender().equalsIgnoreCase("F");
   }

=================/\/\\/\/\===============/\/\/\/\/\/\/\/\===========/\/\/\/\/\/\/\/\=============
======================================================================================================

  Abstract Class && Interface in Java 8 :=
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Abstract Class ----> Having (1)variables          (2)Constructor  
                               (3)Concrete-Methods   (4)Abstract-Method .


   Interface ---->   PSF   (1) Final-Variables                                           (2) Abstract-Methods
                           (3) Default-Methods [No-Need to write in Impl-Class]          (4) Static-Methods 


=================/\/\\/\/\===============/\/\/\/\/\/\/\/\===========/\/\/\/\/\/\/\/\=============
======================================================================================================

 MultipleInheritance555 := 
~~~~~~~~~~~~~~~~~~~~~~~~~
---> Single, Multi-Level, Hierarchiral Inheritabce are suported in java.

     A--B, || A--B && B--C || B-A & C-A
	   
	   
      Multi-Level --->  A(class) --- B&C ( implements Interfaces )
      ~~~~~~~~~~~

In Java 8, we can realize the concept of multiple inheritance through use of default methods without getting into diamond problem.

--->Java does not support multiple inheritance using classes.

---->Multiple inheritance by interface occurs if a class implements multiple interfaces or also if an interface itself extends multiple interfaces.


 Default-Methods :=
~~~~~~~~~~~~~~~~~~~
 --- Default methods enable you to add new functionality to the interfaces and  reduces Burden to classes .
 --- Default-Methods  – will not override, So No-Impact in implementing classes (*******************)

---->But some class specifically wants to override "--default-Method--"  method to add custom logic

----> "--default-Method--" cannot call in Static-block/method, has to call in instance-Block.

                                 <I>.super.<MN>
								 
 Static Methods :=
~~~~~~~~~~~~~~~~~
 ---  To Provide default implementation which should not be Overiden by SubClass. 
 
              // Calling the static method of interface 
              Interface.hello(); 
  
              // Calling the abstract method of interface 
              InterfaceImpl.overrideMethod("Hello, Override Method here"); 


----> Multiple inheritance is a feature of some object-oriented computer programming languages in which an object or class can inherit characteristics and behavior from more than one parent object or parent class

----> if a class implement two interfaces and both defines default methods, then it is essentially inheriting behaviors from two parents which is multiple inheritance. (************)

==============

  https://github.com/kishanjavatrainer/DefaultAndStaticMethodInInterface
  https://github.com/kishanjavatrainer/DefaultMethodsDemo


 --- Interface does not allow to implement Methods of Object Class in it. 
 
 Default-Method ---> Provides default Implementation for classes that Implements it (Does not Force for Impl) //Eg ::Comparator
		                        Can Override in Impl Class.
								If Class Implements 2-Interfaces(having default-Methods) , Compiler Force-To-Override Default-Method. 
								We can call Specific-Interface by changing Overiden-Default-Methods. (*******)
	
 Eg :=
~~~~~~
public interface I2 {

	default void demo() {
		System.out.println("---I2----");
	}

}

public class Test implements I1,I2,I3 {

	@Override  /// ASk to OverRide any One default-Method 
	public void demo() {
		// I3.super.demo();    
		// I2.super.demo(); 
		// System.out.println("---Hello----");
	}
	 
								
		   Static-Method -----> Provides Helper Methods (Does not Force in Impl)
                                CanNot Override , But can have same-Method in Impl Class.
								
			Entry --------------> Inner-Interface
	removeif(), replaceAll() ---> default implementation 
	
	
=================/\/\\/\/\===============/\/\/\/\/\/\/\/\===========/\/\/\/\/\/\/\/\=============
======================================================================================================
 
 LocalDateTime3430 :=
~~~~~~~~~~~~~~~~~~~~
 ---  Supports TimeZone for different Countries.

 --- LocalDate(),  LocalTime(), LocalDateTime(),  


==================================================================================================


